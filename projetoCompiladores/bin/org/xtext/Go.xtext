grammar org.xtext.Go with org.eclipse.xtext.common.Terminals

generate go "http://www.xtext.org/Go"

Model:
	greetings+=program;

program:
	Import_decl; //| Package_clause | Function_decl;
terminal SEMICOLON:
	';';

	//terminal BINARY_OP:
//	"||" | "&&" | REL_OP | ADD_OP | MUL_OP;
//
//terminal REL_OP:
//	"==" | "!=" | "<" | "<=" | ">" | ">=";
//
//terminal ADD_OP:
//	("+" | "-" | "|" | "^");
//
//terminal MUL_OP:
//	("*" | "/" | "%" | "<<" | ">>" | "&" | "&^");
//
//terminal UNARY_OP:
//	"+" | "-" | "!" | "^" | "*" | "&" | "<-";
//
//terminal ASSIGN_OP:
//	(ADD_OP | MUL_OP)? "=";
//
terminal NEWLINE:
	'\u000A';
	//
//terminal LETTER:
//	UNICODE_LETTER | '_';
//
//terminal DECIMAL_DIGITS:
//	(UNICODE_DIGIT)+;
//
terminal HEX_DIGIT:
	UNICODE_DIGIT | 'A'..'F' | 'a'..'f';
	//
//terminal KEYWORDS:
//	'break' | 'default' | 'func' | 'interface' | 'select' | 'case' | 'defer' | 'go' | 'map' | 'struct' | 'chan' | 'else' |
//	'goto' | 'package' | 'switch' | 'const' | "fallthrough" | 'if' | 'range' | 'type' | 'continue' | 'for' | 'import' |
//	'return' | 'var';

Identifier_Unicode_Value:
	LETTER (IDENTIFIER | Unicode_value)
;

terminal IDENTIFIER:
	(LETTER | UNICODE_DIGIT)*;
	//
//fragment OPERATORS:
//	 BINARY_OP | '+=' | '&=' | '(' | ')'  | '-=' | '|=' | '[' | ']' |
//	 '*=' | '^=' | '{' | '}'  | '/=' | '<<=' | '++' | '=' | ':=' | ',' | SEMICOLON |
//	 '%=' | '>>=' | '--' | '...' | '.' | ':' | '&^=' | ASSIGN_OP;
terminal LETTER:
	UNICODE_CHAR | '_';

terminal UNICODE_CHAR:
	'A'..'Z' | 'a'..'z';

terminal fragment UNICODE_DIGIT:
	'0' .. '9';
//Int_lit:
//	DECIMAL_DIGITS | OCTAL_LIT | Hex_lit;
//
//terminal OCTAL_LIT:
//	'0' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7')*;
//
//Hex_lit:
//	'0' ('X' | 'x') HEX_DIGIT (HEX_DIGIT)*;
//
//Float_lit:
//	DECIMAL_DIGITS ('.' (DECIMAL_DIGITS)? (Exponent)? | Exponent)
//	'.' DECIMAL_DIGITS (Exponent)?;
//
//Exponent:
//	('E' | 'e') ('+' | '-')? DECIMAL_DIGITS;
//
//Imaginary_lit:
//	(DECIMAL_DIGITS | Float_lit) 'i';
//
//Rune_lit:
//	"'" (Unicode_value | Byte_value) "'";
Unicode_value:
	Little_u_value | Big_u_value | Escaped_char;

Byte_value:
	Octal_byte_value | Hex_byte_value;

Octal_byte_value:
	"\\" ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2'
	| '3' | '4' | '5' | '6' | '7');

Hex_byte_value:
	"\\" 'x' HEX_DIGIT HEX_DIGIT;

Little_u_value:
	"\\" 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;

Big_u_value:
	"\\" 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;

Escaped_char:
	"\\" ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | "'" | '"');

String_lit:
	Raw_string_lit | Interpreted_string_lit;

Raw_string_lit:
	'`' (UNICODE_CHAR | NEWLINE)* '`';

Interpreted_string_lit:
	'"' (Identifier_Unicode_Value | Byte_value)* '"';
	//
//Literals:
//	(Int_lit | Float_lit | Imaginary_lit | Rune_lit | String_lit);
//
//Comment:
//	ML_COMMENT;
//
//Token:
//	(IDENTIFIER | KEYWORDS | OPERATORS | Literals);
//
//Type:
//	Type_name | Type_lit | "(" Type ")";
//
//Type_name:
//	=> IDENTIFIER | Qualified_ident;
//
//Type_lit:
//	Array_type | Struct_type | Pointer_type | Function_type |
//	Interface_type | Slice_type | Map_type | Channel_type;
//
//Array_type:
//	"[" Array_length "]" Element_type;
//
//Array_length:
//	Parameter_list;
//
//Element_type:
//	=> Type;
//
//Struct_type:
//	"struct" "{" (Field_decl SEMICOLON)* "}";
//
//Field_decl:
//	(Identifier_list Type | Embedded_field) (Tag)?;
//
//Embedded_field:
//	("*")+ =>Type_name;
//
//Tag:
//	String_lit;
//
//Pointer_type:
//	"*" Type;
//
//Function_type:
//	"func" Signature;
//
//Signature:
//	Parameters (=> Result)+;
//
//Result:
//	Parameters | => Type;
//
//Parameters:
//	"(" (Parameter_list (",")+)+ ")";
//
//Parameter_list:
//	Parameter_decl  ("," Parameter_decl)*;
//
//Parameter_decl:
//	(Identifier_list)? ("...")? Type;
//
//Interface_type:
//	=> "interface" "{" (Method_spec SEMICOLON)* "}";
//
//Method_spec:
//	IDENTIFIER Signature | Interface_type_name;
//
//Interface_type_name:
//	Type_name;
//
//Slice_type:
//	"[" "]" Element_type;
//
//Map_type:
//	"map" "[" Key_type "]" Element_type;
//
//Key_type:
//	Type;
//
//Channel_type:
//	(=> "chan" | "chan" "<-" | "<-" "chan") Element_type;
//
//Block:
//	"{" Statement_list "}";
//
//Statement_list:
//	(Statement SEMICOLON)*;
//
//Declaration:
//	Const_decl | Type_decl | Var_decl;
//
//Top_level_decl:
//	Declaration | Function_decl | Method_decl;
//
//Const_decl:
//	"const" Const_spec | "(" (Const_spec SEMICOLON)* ")";
//
//Const_spec:
//	Identifier_list ((Type)? "=" Expression_list)?;
//
//Identifier_list:
//	IDENTIFIER ("," IDENTIFIER)*;
//
//Expression_list:
//	Expression ("," Expression)*;
//
//Type_decl:
//	"type" (Type_spec | "(" (Type_spec SEMICOLON)* ")");
//
//Type_spec:
//	Alias_decl | Type_def;
//
//Alias_decl:
//	IDENTIFIER "=" Type;
//
//Type_def:
//	IDENTIFIER Type;
//
//Var_decl:
//	"var" (Var_spec | "(" (Var_spec SEMICOLON)* ")");
//
//Var_spec:
//	Identifier_list (Type ("=" Expression_list)? | "=" Expression_list);
//
//Short_var_decl:
//	=> Identifier_list ":=" Expression_list;
//
//Function_decl:
//	"func" IDENTIFIER Signature (Function_body)?;
//
//Function_body:
//	Block;
//
//Method_decl:
//	"func" Rreciever IDENTIFIER Signature (Function_body)?;
//
//Rreciever:
//	Parameters;
//
//Operand:
//	Literal | Operand_name | "(" Expression ")";
//
//Literal:
//	Basic_lit | Composite_lit | Function_lit;
//
//Basic_lit:
//	=> Int_lit | Float_lit | Imaginary_lit | Rune_lit | String_lit;
//
//Operand_name:
//	=> IDENTIFIER | Qualified_ident;
//
//Qualified_ident:
//	IDENTIFIER "." IDENTIFIER;
//
//Composite_lit:
//	Literal_type Literal_value;
//
//Literal_type:
//	Struct_type | Array_type | "[" "..." "]" Element_type |
//	Slice_type | Map_type | Type_name;
//
//Literal_value:
//	"{" (Element_list (",")?)? "}";
//
//Element_list:
//	Keyed_element ("," Keyed_element)*;
//
//Keyed_element:
//	=> (Key ":")? Element;
//
//Key:
//	IDENTIFIER | Expression | Literal_value;
//
//Element:
//	Expression | Literal_value;
//
//Function_lit:
//	"func" Signature Function_body;
//
//Primary_expr:
//	Operand |
//	Conversion |
//	Method_expr |
//	=> Primary_expr_selector |
//	Primary_expr_index |
//	Primary_expr_slice |
//	Primary_expr_type_assertion |
//	Primary_expr_arguments;
//
//Primary_expr_selector:
//	Selector Primary_expr_selector | (=> Operand |
//	Conversion |
//	Method_expr);
//
//Primary_expr_index:
//	Index Primary_expr_index | (=> Operand |
//	Conversion |
//	Method_expr);
//
//Primary_expr_slice:
//	Slice Primary_expr_slice | (=> Operand |
//	Conversion |
//	Method_expr);
//
//Primary_expr_type_assertion:
//	Type_assertion Primary_expr_type_assertion | (=> Operand |
//	Conversion |
//	Method_expr);
//
//Primary_expr_arguments:
//	Arguments Primary_expr_arguments | (=> Operand |
//	Conversion |
//	Method_expr);
//
//Selector:
//	"." IDENTIFIER;
//
//Index:
//	"[" Expression "]";
//
//Slice:
//	=> ("[" (Expression)? ":" (Expression)? "]") | ("[" (Expression)? ":" Expression ":" Expression "]");
//
//Type_assertion:
//	"." "(" Type ")";
//
//Arguments:
//	"(" (=> Expression_list | Type ("," Expression_list)? ("...")? (",")?)? ")";
//
//Method_expr:
//	Reciever_type "." IDENTIFIER;
//
//Reciever_type:
//	Type;
//
//Expression:
//	Unary_expr Expression_line;
//
//Expression_line:
//	BINARY_OP Expression Expression_line;
//
//Unary_expr:
//	(Primary_expr | UNARY_OP)+;
//
//Conversion:
//	Type "(" Expression (",")? ")";
//
//Statement:
//	Declaration | Labeled_stmt | Simple_stmt | Go_stmt | Return_stmt |
//	Break_stmt | Continue_stmt | Goto_stmt |
//	"fallthrough" | Block | If_stmt | Switch_stmt |
//	Select_stmt | For_stmt | Defer_stmt;
//
//Simple_stmt:
//	Empty_stmt | Expression_stmt | Send_stmt | Inc_dec_stmt | Assignment | Short_var_decl;
//
//Empty_stmt:
//	WS;
//
//Labeled_stmt:
//	=> IDENTIFIER ":" Statement;
//
//Expression_stmt:
//	Expression;
//
//Send_stmt:
//	=> Channel "<-" Expression;
//
//Channel:
//	Expression;
//
//Inc_dec_stmt:
//	=> Expression ("++" | "--");
//
//Assignment:
//	=> Expression_list ASSIGN_OP Expression_list;
//
//If_stmt:
//	"if" (Simple_stmt SEMICOLON)? => Expression Block ("else" (If_stmt | Block))?;
//
//Switch_stmt:
//	=> Expr_switch_stmt | Type_switch_stmt;
//
//Expr_switch_stmt:
//	"switch" (Simple_stmt SEMICOLON)? => (Expression)? "{" (Expr_case_clause)* "}";
//
//Expr_case_clause:
//	Expr_switch_case ":" Statement_list;
//
//Expr_switch_case:
//	"case" Expression_list | "default";
//
//Type_switch_stmt:
//	"switch" (Simple_stmt SEMICOLON)? => Type_switch_guard "{" (Type_case_clause)* "}";
//
//Type_switch_guard:
//	(IDENTIFIER ":=")? Primary_expr "." "(" "type" ")";
//
//Type_case_clause:
//	Type_switch_case ":" Statement_list;
//
//Type_switch_case:
//	"case" Type_list | "default";
//
//Type_list:
//	Type ("," Type)*;
//
//For_stmt:
//	"for" (=> Condition | For_clause | Range_clause)? Block;
//
//Condition:
//	Expression;
//
//For_clause:
//	(Init_stmt)? SEMICOLON (Condition)? SEMICOLON (Post_stmt)?;
//
//Init_stmt:
//	Simple_stmt;
//
//Post_stmt:
//	Simple_stmt;
//
//Range_clause:
//	(Expression_list "=" | Identifier_list ":=")? "range" Expression;
//
//Go_stmt:
//	"go" Expression;
//
//Select_stmt:
//	"select" "{" (Comm_clause)* "}";
//
//Comm_clause:
//	Comm_case ":" Statement_list;
//
//Comm_case:
//	"case" (Send_stmt | Recv_stmt) | "default";
//
//Recv_stmt:
//	(=> Expression_list "=" | Identifier_list ":=")? Recv_expr;
//
//Recv_expr:
//	Expression;
//
//Return_stmt:
//	"return" (Expression_list)?;
//
//Break_stmt:
//	"break" (IDENTIFIER)?;
//
//Continue_stmt:
//	"continue" (IDENTIFIER)?;
//
//Goto_stmt:
//	"goto" IDENTIFIER;
//
//Defer_stmt:
//	"defer" Expression;
//
//Source_file:
//	Package_clause SEMICOLON (Import_decl SEMICOLON)* (Top_level_decl SEMICOLON)*;
//
//Package_clause:
//	"package" IDENTIFIER;
//
Import_decl:
	"import" (Import_spec | "(" (Import_spec SEMICOLON)* ")");

Import_spec:
	("." | Identifier_Unicode_Value)? String_lit;

