/**
 * generated by Xtext 2.13.0
 */
package org.xtext.validation;

import com.google.common.base.Objects;
import java.util.LinkedHashMap;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.xtext.go.basicLit;
import org.xtext.go.expression;
import org.xtext.validation.AbstractGoValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class GoValidator extends AbstractGoValidator {
  private final LinkedHashMap<Object, Object> ids = CollectionLiterals.<Object, Object>newLinkedHashMap();
  
  @Check
  public Object checkExpression(final expression e) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method checkAritOp(expression, String) from the type GoValidator refers to the missing type Object");
  }
  
  @Check
  public void checkConstDecl(final /* constDecl */Object cd) {
    throw new Error("Unresolved compilation problems:"
      + "\nconstspec cannot be resolved"
      + "\nid cannot be resolved"
      + "\nid cannot be resolved"
      + "\nconstspec cannot be resolved"
      + "\ntp cannot be resolved"
      + "\ntp cannot be resolved"
      + "\nconstspec cannot be resolved"
      + "\nexpressionlist cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nup cannot be resolved"
      + "\npr cannot be resolved"
      + "\nop cannot be resolved"
      + "\nliteral cannot be resolved"
      + "\nbasic cannot be resolved"
      + "\n!== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n!== cannot be resolved"
      + "\n!== cannot be resolved"
      + "\ntoUpperCase cannot be resolved"
      + "\n&& cannot be resolved");
  }
  
  @Check
  public void checkVarDecl(final /* varDecl */Object vd) {
    throw new Error("Unresolved compilation problems:"
      + "\nType mismatch: cannot convert from Object to String"
      + "\nType mismatch: cannot convert from Object to basicLit"
      + "\nType mismatch: cannot convert from Object to String"
      + "\nvarspec cannot be resolved"
      + "\nid cannot be resolved"
      + "\nid cannot be resolved"
      + "\nvarspec cannot be resolved"
      + "\ntp2 cannot be resolved"
      + "\nvarspec cannot be resolved"
      + "\nexpressionlist cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nup cannot be resolved"
      + "\npr cannot be resolved"
      + "\nop cannot be resolved"
      + "\nliteral cannot be resolved"
      + "\nbasic cannot be resolved"
      + "\n!== cannot be resolved"
      + "\n&& cannot be resolved"
      + "\n!== cannot be resolved"
      + "\ntp cannot be resolved"
      + "\n!== cannot be resolved"
      + "\ncharAt cannot be resolved"
      + "\n!== cannot be resolved"
      + "\ntoLowerCase cannot be resolved"
      + "\ncharAt cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nvarspec cannot be resolved"
      + "\nid cannot be resolved"
      + "\nid2 cannot be resolved"
      + "\nvarspec cannot be resolved"
      + "\nexpressionlist cannot be resolved"
      + "\nexpression2 cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nvarspec cannot be resolved"
      + "\nexpressionlist cannot be resolved"
      + "\nexpression2 cannot be resolved"
      + "\nup cannot be resolved"
      + "\npr cannot be resolved"
      + "\nop cannot be resolved"
      + "\nliteral cannot be resolved"
      + "\nbasic cannot be resolved"
      + "\n!== cannot be resolved"
      + "\ntp cannot be resolved");
  }
  
  @Check
  public void imporDeclCheck(final /* importDecl */Object id) {
    throw new Error("Unresolved compilation problems:"
      + "\nimports cannot be resolved"
      + "\nip cannot be resolved"
      + "\nreplaceAll cannot be resolved");
  }
  
  @Check
  public Object idDclrCheck() {
    return null;
  }
  
  @Check
  public Object funcDecla(final /* functionDecl */Object fd) {
    throw new Error("Unresolved compilation problems:"
      + "\nNullObj cannot be resolved."
      + "\nNullObj cannot be resolved."
      + "\nNullObj cannot be resolved."
      + "\nfunctionn cannot be resolved"
      + "\nsignature cannot be resolved"
      + "\nparameters cannot be resolved"
      + "\nparameterlist cannot be resolved"
      + "\nparameterDecl1 cannot be resolved"
      + "\ntype cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nparameterDecl1 cannot be resolved"
      + "\nid cannot be resolved"
      + "\nparameterDecl1 cannot be resolved"
      + "\ntype cannot be resolved"
      + "\ntp cannot be resolved"
      + "\nparameterDecl1 cannot be resolved"
      + "\nid cannot be resolved"
      + "\nparameterDecl1 cannot be resolved"
      + "\ntype cannot be resolved"
      + "\ntp cannot be resolved"
      + "\nparameterDecl1 cannot be resolved"
      + "\nid cannot be resolved"
      + "\nparameterDecl1 cannot be resolved"
      + "\nid cannot be resolved"
      + "\nparameterdecl cannot be resolved"
      + "\ntype cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nid cannot be resolved"
      + "\ntype cannot be resolved"
      + "\ntp cannot be resolved"
      + "\nid cannot be resolved");
  }
  
  @Check
  public void checkOperandName(final /* operand */Object op) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method callMethodCheck(expressionList, String[], operand) from the type GoValidator refers to the missing type expressionList"
      + "\noperandn cannot be resolved"
      + "\nid cannot be resolved"
      + "\noperandn cannot be resolved"
      + "\nid cannot be resolved"
      + "\noperandn cannot be resolved"
      + "\nid cannot be resolved"
      + "\noperandn cannot be resolved"
      + "\nid cannot be resolved"
      + "\nexp cannot be resolved");
  }
  
  @Check
  public Object shortVarDecl(final /* shortVarDecl */Object sv) {
    throw new Error("Unresolved compilation problems:"
      + "\nidl cannot be resolved"
      + "\nid cannot be resolved"
      + "\nepl cannot be resolved");
  }
  
  public void checkRelExp(final expression e) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field bool is undefined for the type basicLit"
      + "\nThe method or field bool is undefined for the type basicLit"
      + "\n=== cannot be resolved"
      + "\n|| cannot be resolved"
      + "\n=== cannot be resolved");
  }
  
  public Object checkAritOp(final expression e, final String binaryOp) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method getType(Object) is undefined"
      + "\nThe method getType(Object) is undefined"
      + "\nThe method getType(Object) is undefined"
      + "\nThe method getType(Object) is undefined"
      + "\nThe method checkTypesInAritimeticOp(String, String, String) is undefined");
  }
  
  public void checkBooleanOp(final expression e, final String binaryOp) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method getType(Object) is undefined"
      + "\nThe method or field up is undefined for the type expression"
      + "\nThe method getType(Object) is undefined"
      + "\nThe method getType(Object) is undefined"
      + "\nThe method getType(Object) is undefined"
      + "\npr cannot be resolved"
      + "\nop cannot be resolved"
      + "\nliteral cannot be resolved"
      + "\n!== cannot be resolved");
  }
  
  protected void checkTypesInBoolOp(final String binaryOp, final String type1, final String type2) {
    if ((Objects.equal(binaryOp, "==") || Objects.equal(binaryOp, "!="))) {
      boolean _notEquals = (!Objects.equal(type1, type2));
      if (_notEquals) {
        this.error(((("Semantic Error: Invalid boolean operation. Mismatched types " + type1) + " and ") + type2), null);
      }
    } else {
      boolean _equals = Objects.equal(type1, "int");
      if (_equals) {
        if ((Objects.equal(type2, "bool") || Objects.equal(type2, "string"))) {
          this.error(((("Semantic Error: Invalid boolean operation. Mismatched types " + type1) + " and ") + type2), null);
        }
      } else {
        boolean _equals_1 = Objects.equal(type1, "float");
        if (_equals_1) {
          if ((Objects.equal(type2, "bool") || Objects.equal(type2, "string"))) {
            this.error(((("Semantic Error: Invalid boolean operation. Mismatched types " + type1) + " and ") + type2), null);
          }
        } else {
          if ((Objects.equal(type1, "bool") || Objects.equal(type2, "bool"))) {
            this.error((("Semantic Error: Invalid boolean operation. Operator " + binaryOp) + 
              " not defined on bool."), null);
          } else {
            boolean _equals_2 = Objects.equal(type1, "string");
            if (_equals_2) {
              boolean _notEquals_1 = (!Objects.equal(type2, "string"));
              if (_notEquals_1) {
                this.error(((("Semantic Error: Invalid boolean operation. Mismatched types " + type1) + " and ") + type2), null);
              }
            }
          }
        }
      }
    }
  }
  
  public String getBasicLitType(final basicLit lit) {
    String _floatLit = lit.getFloatLit();
    boolean _tripleNotEquals = (_floatLit != null);
    if (_tripleNotEquals) {
      return "float";
    } else {
      String _intLit = lit.getIntLit();
      boolean _tripleNotEquals_1 = (_intLit != null);
      if (_tripleNotEquals_1) {
        return "int";
      } else {
        String _stringLit = lit.getStringLit();
        boolean _tripleNotEquals_2 = (_stringLit != null);
        if (_tripleNotEquals_2) {
          return "string";
        }
      }
    }
    return null;
  }
  
  protected boolean isArithimeticOp(final String binaryOperator) {
    return ((((Objects.equal(binaryOperator, "+") || Objects.equal(binaryOperator, "-")) || Objects.equal(binaryOperator, "*")) || Objects.equal(binaryOperator, "/")) || Objects.equal(binaryOperator, "%"));
  }
  
  protected boolean isBooleanOp(final String binaryOperator) {
    return (((((Objects.equal(binaryOperator, "==") || Objects.equal(binaryOperator, "!=")) || Objects.equal(binaryOperator, "<")) || Objects.equal(binaryOperator, "<=")) || Objects.equal(binaryOperator, ">")) || Objects.equal(binaryOperator, ">="));
  }
  
  public Object nullDeclaration(final String id) {
    throw new Error("Unresolved compilation problems:"
      + "\nNullObj cannot be resolved.");
  }
  
  public boolean checkAndMakeDecl(final String id, final String constType, final basicLit literal) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field bool is undefined for the type basicLit"
      + "\nThe method or field bool is undefined for the type basicLit"
      + "\n!== cannot be resolved");
  }
  
  protected void callMethodCheck(final /* expressionList */Object expList, final String[] elements, final /* operand */Object op) {
    throw new Error("Unresolved compilation problems:"
      + "\nexp cannot be resolved"
      + "\nup cannot be resolved"
      + "\npr cannot be resolved"
      + "\nop cannot be resolved"
      + "\noperandn cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nup cannot be resolved"
      + "\npr cannot be resolved"
      + "\nop cannot be resolved"
      + "\noperandn cannot be resolved"
      + "\nid cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nexp cannot be resolved"
      + "\nup cannot be resolved"
      + "\npr cannot be resolved"
      + "\nop cannot be resolved"
      + "\nliteral cannot be resolved"
      + "\nbasic cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nexpression2 cannot be resolved"
      + "\n!== cannot be resolved"
      + "\nexpression2 cannot be resolved"
      + "\noperandn cannot be resolved"
      + "\nid cannot be resolved");
  }
}
