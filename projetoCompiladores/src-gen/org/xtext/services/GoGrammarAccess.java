/*
 * generated by Xtext 2.13.0
 */
package org.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class GoGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Model");
		private final Assignment cGreetingsAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cGreetingsProgramParserRuleCall_0 = (RuleCall)cGreetingsAssignment.eContents().get(0);
		
		//Model:
		//	greetings+=program;
		@Override public ParserRule getRule() { return rule; }
		
		//greetings+=program
		public Assignment getGreetingsAssignment() { return cGreetingsAssignment; }
		
		//program
		public RuleCall getGreetingsProgramParserRuleCall_0() { return cGreetingsProgramParserRuleCall_0; }
	}
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.program");
		private final RuleCall cImport_declParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//program:
		//	Import_decl;
		@Override public ParserRule getRule() { return rule; }
		
		//Import_decl
		public RuleCall getImport_declParserRuleCall() { return cImport_declParserRuleCall; }
	}
	public class Identifier_Unicode_ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Identifier_Unicode_Value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLETTERTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cIDENTIFIERTerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cUnicode_valueParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		
		////
		////terminal KEYWORDS:
		////	'break' | 'default' | 'func' | 'interface' | 'select' | 'case' | 'defer' | 'go' | 'map' | 'struct' | 'chan' | 'else' |
		////	'goto' | 'package' | 'switch' | 'const' | "fallthrough" | 'if' | 'range' | 'type' | 'continue' | 'for' | 'import' |
		////	'return' | 'var';
		//Identifier_Unicode_Value:
		//	LETTER (IDENTIFIER | Unicode_value);
		@Override public ParserRule getRule() { return rule; }
		
		//LETTER (IDENTIFIER | Unicode_value)
		public Group getGroup() { return cGroup; }
		
		//LETTER
		public RuleCall getLETTERTerminalRuleCall_0() { return cLETTERTerminalRuleCall_0; }
		
		//IDENTIFIER | Unicode_value
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall_1_0() { return cIDENTIFIERTerminalRuleCall_1_0; }
		
		//Unicode_value
		public RuleCall getUnicode_valueParserRuleCall_1_1() { return cUnicode_valueParserRuleCall_1_1; }
	}
	public class Unicode_valueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Unicode_value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLittle_u_valueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBig_u_valueParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEscaped_charParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		////Int_lit:
		////	DECIMAL_DIGITS | OCTAL_LIT | Hex_lit;
		////
		////terminal OCTAL_LIT:
		////	'0' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7')*;
		////
		////Hex_lit:
		////	'0' ('X' | 'x') HEX_DIGIT (HEX_DIGIT)*;
		////
		////Float_lit:
		////	DECIMAL_DIGITS ('.' (DECIMAL_DIGITS)? (Exponent)? | Exponent)
		////	'.' DECIMAL_DIGITS (Exponent)?;
		////
		////Exponent:
		////	('E' | 'e') ('+' | '-')? DECIMAL_DIGITS;
		////
		////Imaginary_lit:
		////	(DECIMAL_DIGITS | Float_lit) 'i';
		////
		////Rune_lit:
		////	"'" (Unicode_value | Byte_value) "'";
		//Unicode_value:
		//	Little_u_value | Big_u_value | Escaped_char;
		@Override public ParserRule getRule() { return rule; }
		
		//Little_u_value | Big_u_value | Escaped_char
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Little_u_value
		public RuleCall getLittle_u_valueParserRuleCall_0() { return cLittle_u_valueParserRuleCall_0; }
		
		//Big_u_value
		public RuleCall getBig_u_valueParserRuleCall_1() { return cBig_u_valueParserRuleCall_1; }
		
		//Escaped_char
		public RuleCall getEscaped_charParserRuleCall_2() { return cEscaped_charParserRuleCall_2; }
	}
	public class Byte_valueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Byte_value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cOctal_byte_valueParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cHex_byte_valueParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Byte_value:
		//	Octal_byte_value | Hex_byte_value;
		@Override public ParserRule getRule() { return rule; }
		
		//Octal_byte_value | Hex_byte_value
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Octal_byte_value
		public RuleCall getOctal_byte_valueParserRuleCall_0() { return cOctal_byte_valueParserRuleCall_0; }
		
		//Hex_byte_value
		public RuleCall getHex_byte_valueParserRuleCall_1() { return cHex_byte_valueParserRuleCall_1; }
	}
	public class Octal_byte_valueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Octal_byte_value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBackslashKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cDigitZeroKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cDigitOneKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Keyword cDigitTwoKeyword_1_2 = (Keyword)cAlternatives_1.eContents().get(2);
		private final Keyword cDigitThreeKeyword_1_3 = (Keyword)cAlternatives_1.eContents().get(3);
		private final Keyword cDigitFourKeyword_1_4 = (Keyword)cAlternatives_1.eContents().get(4);
		private final Keyword cDigitFiveKeyword_1_5 = (Keyword)cAlternatives_1.eContents().get(5);
		private final Keyword cDigitSixKeyword_1_6 = (Keyword)cAlternatives_1.eContents().get(6);
		private final Keyword cDigitSevenKeyword_1_7 = (Keyword)cAlternatives_1.eContents().get(7);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Keyword cDigitZeroKeyword_2_0 = (Keyword)cAlternatives_2.eContents().get(0);
		private final Keyword cDigitOneKeyword_2_1 = (Keyword)cAlternatives_2.eContents().get(1);
		private final Keyword cDigitTwoKeyword_2_2 = (Keyword)cAlternatives_2.eContents().get(2);
		private final Keyword cDigitThreeKeyword_2_3 = (Keyword)cAlternatives_2.eContents().get(3);
		private final Keyword cDigitFourKeyword_2_4 = (Keyword)cAlternatives_2.eContents().get(4);
		private final Keyword cDigitFiveKeyword_2_5 = (Keyword)cAlternatives_2.eContents().get(5);
		private final Keyword cDigitSixKeyword_2_6 = (Keyword)cAlternatives_2.eContents().get(6);
		private final Keyword cDigitSevenKeyword_2_7 = (Keyword)cAlternatives_2.eContents().get(7);
		private final Alternatives cAlternatives_3 = (Alternatives)cGroup.eContents().get(3);
		private final Keyword cDigitZeroKeyword_3_0 = (Keyword)cAlternatives_3.eContents().get(0);
		private final Keyword cDigitOneKeyword_3_1 = (Keyword)cAlternatives_3.eContents().get(1);
		private final Keyword cDigitTwoKeyword_3_2 = (Keyword)cAlternatives_3.eContents().get(2);
		private final Keyword cDigitThreeKeyword_3_3 = (Keyword)cAlternatives_3.eContents().get(3);
		private final Keyword cDigitFourKeyword_3_4 = (Keyword)cAlternatives_3.eContents().get(4);
		private final Keyword cDigitFiveKeyword_3_5 = (Keyword)cAlternatives_3.eContents().get(5);
		private final Keyword cDigitSixKeyword_3_6 = (Keyword)cAlternatives_3.eContents().get(6);
		private final Keyword cDigitSevenKeyword_3_7 = (Keyword)cAlternatives_3.eContents().get(7);
		
		//Octal_byte_value:
		//	"\\" ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2'
		//	| '3' | '4' | '5' | '6' | '7');
		@Override public ParserRule getRule() { return rule; }
		
		//"\\" ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2' |
		//'3' | '4' | '5' | '6' | '7')
		public Group getGroup() { return cGroup; }
		
		//"\\"
		public Keyword getBackslashKeyword_0() { return cBackslashKeyword_0; }
		
		//'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'0'
		public Keyword getDigitZeroKeyword_1_0() { return cDigitZeroKeyword_1_0; }
		
		//'1'
		public Keyword getDigitOneKeyword_1_1() { return cDigitOneKeyword_1_1; }
		
		//'2'
		public Keyword getDigitTwoKeyword_1_2() { return cDigitTwoKeyword_1_2; }
		
		//'3'
		public Keyword getDigitThreeKeyword_1_3() { return cDigitThreeKeyword_1_3; }
		
		//'4'
		public Keyword getDigitFourKeyword_1_4() { return cDigitFourKeyword_1_4; }
		
		//'5'
		public Keyword getDigitFiveKeyword_1_5() { return cDigitFiveKeyword_1_5; }
		
		//'6'
		public Keyword getDigitSixKeyword_1_6() { return cDigitSixKeyword_1_6; }
		
		//'7'
		public Keyword getDigitSevenKeyword_1_7() { return cDigitSevenKeyword_1_7; }
		
		//'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//'0'
		public Keyword getDigitZeroKeyword_2_0() { return cDigitZeroKeyword_2_0; }
		
		//'1'
		public Keyword getDigitOneKeyword_2_1() { return cDigitOneKeyword_2_1; }
		
		//'2'
		public Keyword getDigitTwoKeyword_2_2() { return cDigitTwoKeyword_2_2; }
		
		//'3'
		public Keyword getDigitThreeKeyword_2_3() { return cDigitThreeKeyword_2_3; }
		
		//'4'
		public Keyword getDigitFourKeyword_2_4() { return cDigitFourKeyword_2_4; }
		
		//'5'
		public Keyword getDigitFiveKeyword_2_5() { return cDigitFiveKeyword_2_5; }
		
		//'6'
		public Keyword getDigitSixKeyword_2_6() { return cDigitSixKeyword_2_6; }
		
		//'7'
		public Keyword getDigitSevenKeyword_2_7() { return cDigitSevenKeyword_2_7; }
		
		//'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7'
		public Alternatives getAlternatives_3() { return cAlternatives_3; }
		
		//'0'
		public Keyword getDigitZeroKeyword_3_0() { return cDigitZeroKeyword_3_0; }
		
		//'1'
		public Keyword getDigitOneKeyword_3_1() { return cDigitOneKeyword_3_1; }
		
		//'2'
		public Keyword getDigitTwoKeyword_3_2() { return cDigitTwoKeyword_3_2; }
		
		//'3'
		public Keyword getDigitThreeKeyword_3_3() { return cDigitThreeKeyword_3_3; }
		
		//'4'
		public Keyword getDigitFourKeyword_3_4() { return cDigitFourKeyword_3_4; }
		
		//'5'
		public Keyword getDigitFiveKeyword_3_5() { return cDigitFiveKeyword_3_5; }
		
		//'6'
		public Keyword getDigitSixKeyword_3_6() { return cDigitSixKeyword_3_6; }
		
		//'7'
		public Keyword getDigitSevenKeyword_3_7() { return cDigitSevenKeyword_3_7; }
	}
	public class Hex_byte_valueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Hex_byte_value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBackslashKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cXKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cHEX_DIGITTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cHEX_DIGITTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//Hex_byte_value:
		//	"\\" 'x' HEX_DIGIT HEX_DIGIT;
		@Override public ParserRule getRule() { return rule; }
		
		//"\\" 'x' HEX_DIGIT HEX_DIGIT
		public Group getGroup() { return cGroup; }
		
		//"\\"
		public Keyword getBackslashKeyword_0() { return cBackslashKeyword_0; }
		
		//'x'
		public Keyword getXKeyword_1() { return cXKeyword_1; }
		
		//HEX_DIGIT
		public RuleCall getHEX_DIGITTerminalRuleCall_2() { return cHEX_DIGITTerminalRuleCall_2; }
		
		//HEX_DIGIT
		public RuleCall getHEX_DIGITTerminalRuleCall_3() { return cHEX_DIGITTerminalRuleCall_3; }
	}
	public class Little_u_valueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Little_u_value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBackslashKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cUKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cHEX_DIGITTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cHEX_DIGITTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final RuleCall cHEX_DIGITTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final RuleCall cHEX_DIGITTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//Little_u_value:
		//	"\\" 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;
		@Override public ParserRule getRule() { return rule; }
		
		//"\\" 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
		public Group getGroup() { return cGroup; }
		
		//"\\"
		public Keyword getBackslashKeyword_0() { return cBackslashKeyword_0; }
		
		//'u'
		public Keyword getUKeyword_1() { return cUKeyword_1; }
		
		//HEX_DIGIT
		public RuleCall getHEX_DIGITTerminalRuleCall_2() { return cHEX_DIGITTerminalRuleCall_2; }
		
		//HEX_DIGIT
		public RuleCall getHEX_DIGITTerminalRuleCall_3() { return cHEX_DIGITTerminalRuleCall_3; }
		
		//HEX_DIGIT
		public RuleCall getHEX_DIGITTerminalRuleCall_4() { return cHEX_DIGITTerminalRuleCall_4; }
		
		//HEX_DIGIT
		public RuleCall getHEX_DIGITTerminalRuleCall_5() { return cHEX_DIGITTerminalRuleCall_5; }
	}
	public class Big_u_valueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Big_u_value");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBackslashKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cUKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cHEX_DIGITTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cHEX_DIGITTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final RuleCall cHEX_DIGITTerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final RuleCall cHEX_DIGITTerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//Big_u_value:
		//	"\\" 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;
		@Override public ParserRule getRule() { return rule; }
		
		//"\\" 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
		public Group getGroup() { return cGroup; }
		
		//"\\"
		public Keyword getBackslashKeyword_0() { return cBackslashKeyword_0; }
		
		//'U'
		public Keyword getUKeyword_1() { return cUKeyword_1; }
		
		//HEX_DIGIT
		public RuleCall getHEX_DIGITTerminalRuleCall_2() { return cHEX_DIGITTerminalRuleCall_2; }
		
		//HEX_DIGIT
		public RuleCall getHEX_DIGITTerminalRuleCall_3() { return cHEX_DIGITTerminalRuleCall_3; }
		
		//HEX_DIGIT
		public RuleCall getHEX_DIGITTerminalRuleCall_4() { return cHEX_DIGITTerminalRuleCall_4; }
		
		//HEX_DIGIT
		public RuleCall getHEX_DIGITTerminalRuleCall_5() { return cHEX_DIGITTerminalRuleCall_5; }
	}
	public class Escaped_charElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Escaped_char");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBackslashKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cAKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cBKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final Keyword cFKeyword_1_2 = (Keyword)cAlternatives_1.eContents().get(2);
		private final Keyword cNKeyword_1_3 = (Keyword)cAlternatives_1.eContents().get(3);
		private final Keyword cRKeyword_1_4 = (Keyword)cAlternatives_1.eContents().get(4);
		private final Keyword cTKeyword_1_5 = (Keyword)cAlternatives_1.eContents().get(5);
		private final Keyword cVKeyword_1_6 = (Keyword)cAlternatives_1.eContents().get(6);
		private final Keyword cBackslashKeyword_1_7 = (Keyword)cAlternatives_1.eContents().get(7);
		private final Keyword cApostropheKeyword_1_8 = (Keyword)cAlternatives_1.eContents().get(8);
		private final Keyword cQuotationMarkKeyword_1_9 = (Keyword)cAlternatives_1.eContents().get(9);
		
		//Escaped_char:
		//	"\\" ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | "'" | '"');
		@Override public ParserRule getRule() { return rule; }
		
		//"\\" ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | "'" | '"')
		public Group getGroup() { return cGroup; }
		
		//"\\"
		public Keyword getBackslashKeyword_0() { return cBackslashKeyword_0; }
		
		//'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | "'" | '"'
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'a'
		public Keyword getAKeyword_1_0() { return cAKeyword_1_0; }
		
		//'b'
		public Keyword getBKeyword_1_1() { return cBKeyword_1_1; }
		
		//'f'
		public Keyword getFKeyword_1_2() { return cFKeyword_1_2; }
		
		//'n'
		public Keyword getNKeyword_1_3() { return cNKeyword_1_3; }
		
		//'r'
		public Keyword getRKeyword_1_4() { return cRKeyword_1_4; }
		
		//'t'
		public Keyword getTKeyword_1_5() { return cTKeyword_1_5; }
		
		//'v'
		public Keyword getVKeyword_1_6() { return cVKeyword_1_6; }
		
		//'\\'
		public Keyword getBackslashKeyword_1_7() { return cBackslashKeyword_1_7; }
		
		//"'"
		public Keyword getApostropheKeyword_1_8() { return cApostropheKeyword_1_8; }
		
		//'"'
		public Keyword getQuotationMarkKeyword_1_9() { return cQuotationMarkKeyword_1_9; }
	}
	public class String_litElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.String_lit");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRaw_string_litParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cInterpreted_string_litParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//String_lit:
		//	Raw_string_lit | Interpreted_string_lit;
		@Override public ParserRule getRule() { return rule; }
		
		//Raw_string_lit | Interpreted_string_lit
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Raw_string_lit
		public RuleCall getRaw_string_litParserRuleCall_0() { return cRaw_string_litParserRuleCall_0; }
		
		//Interpreted_string_lit
		public RuleCall getInterpreted_string_litParserRuleCall_1() { return cInterpreted_string_litParserRuleCall_1; }
	}
	public class Raw_string_litElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Raw_string_lit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGraveAccentKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cUNICODE_CHARTerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cNEWLINETerminalRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final Keyword cGraveAccentKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Raw_string_lit:
		//	'`' (UNICODE_CHAR | NEWLINE)* '`';
		@Override public ParserRule getRule() { return rule; }
		
		//'`' (UNICODE_CHAR | NEWLINE)* '`'
		public Group getGroup() { return cGroup; }
		
		//'`'
		public Keyword getGraveAccentKeyword_0() { return cGraveAccentKeyword_0; }
		
		//(UNICODE_CHAR | NEWLINE)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//UNICODE_CHAR
		public RuleCall getUNICODE_CHARTerminalRuleCall_1_0() { return cUNICODE_CHARTerminalRuleCall_1_0; }
		
		//NEWLINE
		public RuleCall getNEWLINETerminalRuleCall_1_1() { return cNEWLINETerminalRuleCall_1_1; }
		
		//'`'
		public Keyword getGraveAccentKeyword_2() { return cGraveAccentKeyword_2; }
	}
	public class Interpreted_string_litElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Interpreted_string_lit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cQuotationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cIdentifier_Unicode_ValueParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cByte_valueParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final Keyword cQuotationMarkKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Interpreted_string_lit:
		//	'"' (Identifier_Unicode_Value | Byte_value)* '"';
		@Override public ParserRule getRule() { return rule; }
		
		//'"' (Identifier_Unicode_Value | Byte_value)* '"'
		public Group getGroup() { return cGroup; }
		
		//'"'
		public Keyword getQuotationMarkKeyword_0() { return cQuotationMarkKeyword_0; }
		
		//(Identifier_Unicode_Value | Byte_value)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//Identifier_Unicode_Value
		public RuleCall getIdentifier_Unicode_ValueParserRuleCall_1_0() { return cIdentifier_Unicode_ValueParserRuleCall_1_0; }
		
		//Byte_value
		public RuleCall getByte_valueParserRuleCall_1_1() { return cByte_valueParserRuleCall_1_1; }
		
		//'"'
		public Keyword getQuotationMarkKeyword_2() { return cQuotationMarkKeyword_2; }
	}
	public class Import_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Import_decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cImport_specParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final RuleCall cImport_specParserRuleCall_1_1_1_0 = (RuleCall)cGroup_1_1_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_1_1_1_1 = (RuleCall)cGroup_1_1_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_1_2 = (Keyword)cGroup_1_1.eContents().get(2);
		
		////
		////Literals:
		////	(Int_lit | Float_lit | Imaginary_lit | Rune_lit | String_lit);
		////
		////Comment:
		////	ML_COMMENT;
		////
		////Token:
		////	(IDENTIFIER | KEYWORDS | OPERATORS | Literals);
		////
		////Type:
		////	Type_name | Type_lit | "(" Type ")";
		////
		////Type_name:
		////	=> IDENTIFIER | Qualified_ident;
		////
		////Type_lit:
		////	Array_type | Struct_type | Pointer_type | Function_type |
		////	Interface_type | Slice_type | Map_type | Channel_type;
		////
		////Array_type:
		////	"[" Array_length "]" Element_type;
		////
		////Array_length:
		////	Parameter_list;
		////
		////Element_type:
		////	=> Type;
		////
		////Struct_type:
		////	"struct" "{" (Field_decl SEMICOLON)* "}";
		////
		////Field_decl:
		////	(Identifier_list Type | Embedded_field) (Tag)?;
		////
		////Embedded_field:
		////	("*")+ =>Type_name;
		////
		////Tag:
		////	String_lit;
		////
		////Pointer_type:
		////	"*" Type;
		////
		////Function_type:
		////	"func" Signature;
		////
		////Signature:
		////	Parameters (=> Result)+;
		////
		////Result:
		////	Parameters | => Type;
		////
		////Parameters:
		////	"(" (Parameter_list (",")+)+ ")";
		////
		////Parameter_list:
		////	Parameter_decl  ("," Parameter_decl)*;
		////
		////Parameter_decl:
		////	(Identifier_list)? ("...")? Type;
		////
		////Interface_type:
		////	=> "interface" "{" (Method_spec SEMICOLON)* "}";
		////
		////Method_spec:
		////	IDENTIFIER Signature | Interface_type_name;
		////
		////Interface_type_name:
		////	Type_name;
		////
		////Slice_type:
		////	"[" "]" Element_type;
		////
		////Map_type:
		////	"map" "[" Key_type "]" Element_type;
		////
		////Key_type:
		////	Type;
		////
		////Channel_type:
		////	(=> "chan" | "chan" "<-" | "<-" "chan") Element_type;
		////
		////Block:
		////	"{" Statement_list "}";
		////
		////Statement_list:
		////	(Statement SEMICOLON)*;
		////
		////Declaration:
		////	Const_decl | Type_decl | Var_decl;
		////
		////Top_level_decl:
		////	Declaration | Function_decl | Method_decl;
		////
		////Const_decl:
		////	"const" Const_spec | "(" (Const_spec SEMICOLON)* ")";
		////
		////Const_spec:
		////	Identifier_list ((Type)? "=" Expression_list)?;
		////
		////Identifier_list:
		////	IDENTIFIER ("," IDENTIFIER)*;
		////
		////Expression_list:
		////	Expression ("," Expression)*;
		////
		////Type_decl:
		////	"type" (Type_spec | "(" (Type_spec SEMICOLON)* ")");
		////
		////Type_spec:
		////	Alias_decl | Type_def;
		////
		////Alias_decl:
		////	IDENTIFIER "=" Type;
		////
		////Type_def:
		////	IDENTIFIER Type;
		////
		////Var_decl:
		////	"var" (Var_spec | "(" (Var_spec SEMICOLON)* ")");
		////
		////Var_spec:
		////	Identifier_list (Type ("=" Expression_list)? | "=" Expression_list);
		////
		////Short_var_decl:
		////	=> Identifier_list ":=" Expression_list;
		////
		////Function_decl:
		////	"func" IDENTIFIER Signature (Function_body)?;
		////
		////Function_body:
		////	Block;
		////
		////Method_decl:
		////	"func" Rreciever IDENTIFIER Signature (Function_body)?;
		////
		////Rreciever:
		////	Parameters;
		////
		////Operand:
		////	Literal | Operand_name | "(" Expression ")";
		////
		////Literal:
		////	Basic_lit | Composite_lit | Function_lit;
		////
		////Basic_lit:
		////	=> Int_lit | Float_lit | Imaginary_lit | Rune_lit | String_lit;
		////
		////Operand_name:
		////	=> IDENTIFIER | Qualified_ident;
		////
		////Qualified_ident:
		////	IDENTIFIER "." IDENTIFIER;
		////
		////Composite_lit:
		////	Literal_type Literal_value;
		////
		////Literal_type:
		////	Struct_type | Array_type | "[" "..." "]" Element_type |
		////	Slice_type | Map_type | Type_name;
		////
		////Literal_value:
		////	"{" (Element_list (",")?)? "}";
		////
		////Element_list:
		////	Keyed_element ("," Keyed_element)*;
		////
		////Keyed_element:
		////	=> (Key ":")? Element;
		////
		////Key:
		////	IDENTIFIER | Expression | Literal_value;
		////
		////Element:
		////	Expression | Literal_value;
		////
		////Function_lit:
		////	"func" Signature Function_body;
		////
		////Primary_expr:
		////	Operand |
		////	Conversion |
		////	Method_expr |
		////	=> Primary_expr_selector |
		////	Primary_expr_index |
		////	Primary_expr_slice |
		////	Primary_expr_type_assertion |
		////	Primary_expr_arguments;
		////
		////Primary_expr_selector:
		////	Selector Primary_expr_selector | (=> Operand |
		////	Conversion |
		////	Method_expr);
		////
		////Primary_expr_index:
		////	Index Primary_expr_index | (=> Operand |
		////	Conversion |
		////	Method_expr);
		////
		////Primary_expr_slice:
		////	Slice Primary_expr_slice | (=> Operand |
		////	Conversion |
		////	Method_expr);
		////
		////Primary_expr_type_assertion:
		////	Type_assertion Primary_expr_type_assertion | (=> Operand |
		////	Conversion |
		////	Method_expr);
		////
		////Primary_expr_arguments:
		////	Arguments Primary_expr_arguments | (=> Operand |
		////	Conversion |
		////	Method_expr);
		////
		////Selector:
		////	"." IDENTIFIER;
		////
		////Index:
		////	"[" Expression "]";
		////
		////Slice:
		////	=> ("[" (Expression)? ":" (Expression)? "]") | ("[" (Expression)? ":" Expression ":" Expression "]");
		////
		////Type_assertion:
		////	"." "(" Type ")";
		////
		////Arguments:
		////	"(" (=> Expression_list | Type ("," Expression_list)? ("...")? (",")?)? ")";
		////
		////Method_expr:
		////	Reciever_type "." IDENTIFIER;
		////
		////Reciever_type:
		////	Type;
		////
		////Expression:
		////	Unary_expr Expression_line;
		////
		////Expression_line:
		////	BINARY_OP Expression Expression_line;
		////
		////Unary_expr:
		////	(Primary_expr | UNARY_OP)+;
		////
		////Conversion:
		////	Type "(" Expression (",")? ")";
		////
		////Statement:
		////	Declaration | Labeled_stmt | Simple_stmt | Go_stmt | Return_stmt |
		////	Break_stmt | Continue_stmt | Goto_stmt |
		////	"fallthrough" | Block | If_stmt | Switch_stmt |
		////	Select_stmt | For_stmt | Defer_stmt;
		////
		////Simple_stmt:
		////	Empty_stmt | Expression_stmt | Send_stmt | Inc_dec_stmt | Assignment | Short_var_decl;
		////
		////Empty_stmt:
		////	WS;
		////
		////Labeled_stmt:
		////	=> IDENTIFIER ":" Statement;
		////
		////Expression_stmt:
		////	Expression;
		////
		////Send_stmt:
		////	=> Channel "<-" Expression;
		////
		////Channel:
		////	Expression;
		////
		////Inc_dec_stmt:
		////	=> Expression ("++" | "--");
		////
		////Assignment:
		////	=> Expression_list ASSIGN_OP Expression_list;
		////
		////If_stmt:
		////	"if" (Simple_stmt SEMICOLON)? => Expression Block ("else" (If_stmt | Block))?;
		////
		////Switch_stmt:
		////	=> Expr_switch_stmt | Type_switch_stmt;
		////
		////Expr_switch_stmt:
		////	"switch" (Simple_stmt SEMICOLON)? => (Expression)? "{" (Expr_case_clause)* "}";
		////
		////Expr_case_clause:
		////	Expr_switch_case ":" Statement_list;
		////
		////Expr_switch_case:
		////	"case" Expression_list | "default";
		////
		////Type_switch_stmt:
		////	"switch" (Simple_stmt SEMICOLON)? => Type_switch_guard "{" (Type_case_clause)* "}";
		////
		////Type_switch_guard:
		////	(IDENTIFIER ":=")? Primary_expr "." "(" "type" ")";
		////
		////Type_case_clause:
		////	Type_switch_case ":" Statement_list;
		////
		////Type_switch_case:
		////	"case" Type_list | "default";
		////
		////Type_list:
		////	Type ("," Type)*;
		////
		////For_stmt:
		////	"for" (=> Condition | For_clause | Range_clause)? Block;
		////
		////Condition:
		////	Expression;
		////
		////For_clause:
		////	(Init_stmt)? SEMICOLON (Condition)? SEMICOLON (Post_stmt)?;
		////
		////Init_stmt:
		////	Simple_stmt;
		////
		////Post_stmt:
		////	Simple_stmt;
		////
		////Range_clause:
		////	(Expression_list "=" | Identifier_list ":=")? "range" Expression;
		////
		////Go_stmt:
		////	"go" Expression;
		////
		////Select_stmt:
		////	"select" "{" (Comm_clause)* "}";
		////
		////Comm_clause:
		////	Comm_case ":" Statement_list;
		////
		////Comm_case:
		////	"case" (Send_stmt | Recv_stmt) | "default";
		////
		////Recv_stmt:
		////	(=> Expression_list "=" | Identifier_list ":=")? Recv_expr;
		////
		////Recv_expr:
		////	Expression;
		////
		////Return_stmt:
		////	"return" (Expression_list)?;
		////
		////Break_stmt:
		////	"break" (IDENTIFIER)?;
		////
		////Continue_stmt:
		////	"continue" (IDENTIFIER)?;
		////
		////Goto_stmt:
		////	"goto" IDENTIFIER;
		////
		////Defer_stmt:
		////	"defer" Expression;
		////
		////Source_file:
		////	Package_clause SEMICOLON (Import_decl SEMICOLON)* (Top_level_decl SEMICOLON)*;
		////
		////Package_clause:
		////	"package" IDENTIFIER;
		////
		//Import_decl:
		//	"import" (Import_spec | "(" (Import_spec SEMICOLON)* ")");
		@Override public ParserRule getRule() { return rule; }
		
		//"import" (Import_spec | "(" (Import_spec SEMICOLON)* ")")
		public Group getGroup() { return cGroup; }
		
		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//Import_spec | "(" (Import_spec SEMICOLON)* ")"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//Import_spec
		public RuleCall getImport_specParserRuleCall_1_0() { return cImport_specParserRuleCall_1_0; }
		
		//"(" (Import_spec SEMICOLON)* ")"
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1_1_0() { return cLeftParenthesisKeyword_1_1_0; }
		
		//(Import_spec SEMICOLON)*
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }
		
		//Import_spec
		public RuleCall getImport_specParserRuleCall_1_1_1_0() { return cImport_specParserRuleCall_1_1_1_0; }
		
		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_1_1_1_1() { return cSEMICOLONTerminalRuleCall_1_1_1_1; }
		
		//")"
		public Keyword getRightParenthesisKeyword_1_1_2() { return cRightParenthesisKeyword_1_1_2; }
	}
	public class Import_specElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Import_spec");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final RuleCall cIdentifier_Unicode_ValueParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cString_litParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Import_spec:
		//	("." | Identifier_Unicode_Value)? String_lit;
		@Override public ParserRule getRule() { return rule; }
		
		//("." | Identifier_Unicode_Value)? String_lit
		public Group getGroup() { return cGroup; }
		
		//("." | Identifier_Unicode_Value)?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//"."
		public Keyword getFullStopKeyword_0_0() { return cFullStopKeyword_0_0; }
		
		//Identifier_Unicode_Value
		public RuleCall getIdentifier_Unicode_ValueParserRuleCall_0_1() { return cIdentifier_Unicode_ValueParserRuleCall_0_1; }
		
		//String_lit
		public RuleCall getString_litParserRuleCall_1() { return cString_litParserRuleCall_1; }
	}
	
	
	private final ModelElements pModel;
	private final ProgramElements pProgram;
	private final TerminalRule tSEMICOLON;
	private final TerminalRule tNEWLINE;
	private final TerminalRule tHEX_DIGIT;
	private final Identifier_Unicode_ValueElements pIdentifier_Unicode_Value;
	private final TerminalRule tIDENTIFIER;
	private final TerminalRule tLETTER;
	private final TerminalRule tUNICODE_CHAR;
	private final TerminalRule tUNICODE_DIGIT;
	private final Unicode_valueElements pUnicode_value;
	private final Byte_valueElements pByte_value;
	private final Octal_byte_valueElements pOctal_byte_value;
	private final Hex_byte_valueElements pHex_byte_value;
	private final Little_u_valueElements pLittle_u_value;
	private final Big_u_valueElements pBig_u_value;
	private final Escaped_charElements pEscaped_char;
	private final String_litElements pString_lit;
	private final Raw_string_litElements pRaw_string_lit;
	private final Interpreted_string_litElements pInterpreted_string_lit;
	private final Import_declElements pImport_decl;
	private final Import_specElements pImport_spec;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public GoGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.pProgram = new ProgramElements();
		this.tSEMICOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.SEMICOLON");
		this.tNEWLINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.NEWLINE");
		this.tHEX_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.HEX_DIGIT");
		this.pIdentifier_Unicode_Value = new Identifier_Unicode_ValueElements();
		this.tIDENTIFIER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.IDENTIFIER");
		this.tLETTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.LETTER");
		this.tUNICODE_CHAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.UNICODE_CHAR");
		this.tUNICODE_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.UNICODE_DIGIT");
		this.pUnicode_value = new Unicode_valueElements();
		this.pByte_value = new Byte_valueElements();
		this.pOctal_byte_value = new Octal_byte_valueElements();
		this.pHex_byte_value = new Hex_byte_valueElements();
		this.pLittle_u_value = new Little_u_valueElements();
		this.pBig_u_value = new Big_u_valueElements();
		this.pEscaped_char = new Escaped_charElements();
		this.pString_lit = new String_litElements();
		this.pRaw_string_lit = new Raw_string_litElements();
		this.pInterpreted_string_lit = new Interpreted_string_litElements();
		this.pImport_decl = new Import_declElements();
		this.pImport_spec = new Import_specElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.Go".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	greetings+=program;
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//program:
	//	Import_decl;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	//terminal SEMICOLON:
	//	';';
	public TerminalRule getSEMICOLONRule() {
		return tSEMICOLON;
	}
	
	//terminal NEWLINE:
	//	'\\u000A';
	public TerminalRule getNEWLINERule() {
		return tNEWLINE;
	}
	
	//terminal HEX_DIGIT:
	//	UNICODE_DIGIT | 'A'..'F' | 'a'..'f';
	public TerminalRule getHEX_DIGITRule() {
		return tHEX_DIGIT;
	}
	
	////
	////terminal KEYWORDS:
	////	'break' | 'default' | 'func' | 'interface' | 'select' | 'case' | 'defer' | 'go' | 'map' | 'struct' | 'chan' | 'else' |
	////	'goto' | 'package' | 'switch' | 'const' | "fallthrough" | 'if' | 'range' | 'type' | 'continue' | 'for' | 'import' |
	////	'return' | 'var';
	//Identifier_Unicode_Value:
	//	LETTER (IDENTIFIER | Unicode_value);
	public Identifier_Unicode_ValueElements getIdentifier_Unicode_ValueAccess() {
		return pIdentifier_Unicode_Value;
	}
	
	public ParserRule getIdentifier_Unicode_ValueRule() {
		return getIdentifier_Unicode_ValueAccess().getRule();
	}
	
	//terminal IDENTIFIER:
	//	LETTER | UNICODE_DIGIT*;
	public TerminalRule getIDENTIFIERRule() {
		return tIDENTIFIER;
	}
	
	//terminal LETTER:
	//	UNICODE_CHAR | '_';
	public TerminalRule getLETTERRule() {
		return tLETTER;
	}
	
	//terminal UNICODE_CHAR:
	//	'A'..'Z' | 'a'..'z';
	public TerminalRule getUNICODE_CHARRule() {
		return tUNICODE_CHAR;
	}
	
	//terminal fragment UNICODE_DIGIT:
	//	'0'..'9';
	public TerminalRule getUNICODE_DIGITRule() {
		return tUNICODE_DIGIT;
	}
	
	////Int_lit:
	////	DECIMAL_DIGITS | OCTAL_LIT | Hex_lit;
	////
	////terminal OCTAL_LIT:
	////	'0' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7')*;
	////
	////Hex_lit:
	////	'0' ('X' | 'x') HEX_DIGIT (HEX_DIGIT)*;
	////
	////Float_lit:
	////	DECIMAL_DIGITS ('.' (DECIMAL_DIGITS)? (Exponent)? | Exponent)
	////	'.' DECIMAL_DIGITS (Exponent)?;
	////
	////Exponent:
	////	('E' | 'e') ('+' | '-')? DECIMAL_DIGITS;
	////
	////Imaginary_lit:
	////	(DECIMAL_DIGITS | Float_lit) 'i';
	////
	////Rune_lit:
	////	"'" (Unicode_value | Byte_value) "'";
	//Unicode_value:
	//	Little_u_value | Big_u_value | Escaped_char;
	public Unicode_valueElements getUnicode_valueAccess() {
		return pUnicode_value;
	}
	
	public ParserRule getUnicode_valueRule() {
		return getUnicode_valueAccess().getRule();
	}
	
	//Byte_value:
	//	Octal_byte_value | Hex_byte_value;
	public Byte_valueElements getByte_valueAccess() {
		return pByte_value;
	}
	
	public ParserRule getByte_valueRule() {
		return getByte_valueAccess().getRule();
	}
	
	//Octal_byte_value:
	//	"\\" ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2'
	//	| '3' | '4' | '5' | '6' | '7');
	public Octal_byte_valueElements getOctal_byte_valueAccess() {
		return pOctal_byte_value;
	}
	
	public ParserRule getOctal_byte_valueRule() {
		return getOctal_byte_valueAccess().getRule();
	}
	
	//Hex_byte_value:
	//	"\\" 'x' HEX_DIGIT HEX_DIGIT;
	public Hex_byte_valueElements getHex_byte_valueAccess() {
		return pHex_byte_value;
	}
	
	public ParserRule getHex_byte_valueRule() {
		return getHex_byte_valueAccess().getRule();
	}
	
	//Little_u_value:
	//	"\\" 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;
	public Little_u_valueElements getLittle_u_valueAccess() {
		return pLittle_u_value;
	}
	
	public ParserRule getLittle_u_valueRule() {
		return getLittle_u_valueAccess().getRule();
	}
	
	//Big_u_value:
	//	"\\" 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;
	public Big_u_valueElements getBig_u_valueAccess() {
		return pBig_u_value;
	}
	
	public ParserRule getBig_u_valueRule() {
		return getBig_u_valueAccess().getRule();
	}
	
	//Escaped_char:
	//	"\\" ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | "'" | '"');
	public Escaped_charElements getEscaped_charAccess() {
		return pEscaped_char;
	}
	
	public ParserRule getEscaped_charRule() {
		return getEscaped_charAccess().getRule();
	}
	
	//String_lit:
	//	Raw_string_lit | Interpreted_string_lit;
	public String_litElements getString_litAccess() {
		return pString_lit;
	}
	
	public ParserRule getString_litRule() {
		return getString_litAccess().getRule();
	}
	
	//Raw_string_lit:
	//	'`' (UNICODE_CHAR | NEWLINE)* '`';
	public Raw_string_litElements getRaw_string_litAccess() {
		return pRaw_string_lit;
	}
	
	public ParserRule getRaw_string_litRule() {
		return getRaw_string_litAccess().getRule();
	}
	
	//Interpreted_string_lit:
	//	'"' (Identifier_Unicode_Value | Byte_value)* '"';
	public Interpreted_string_litElements getInterpreted_string_litAccess() {
		return pInterpreted_string_lit;
	}
	
	public ParserRule getInterpreted_string_litRule() {
		return getInterpreted_string_litAccess().getRule();
	}
	
	////
	////Literals:
	////	(Int_lit | Float_lit | Imaginary_lit | Rune_lit | String_lit);
	////
	////Comment:
	////	ML_COMMENT;
	////
	////Token:
	////	(IDENTIFIER | KEYWORDS | OPERATORS | Literals);
	////
	////Type:
	////	Type_name | Type_lit | "(" Type ")";
	////
	////Type_name:
	////	=> IDENTIFIER | Qualified_ident;
	////
	////Type_lit:
	////	Array_type | Struct_type | Pointer_type | Function_type |
	////	Interface_type | Slice_type | Map_type | Channel_type;
	////
	////Array_type:
	////	"[" Array_length "]" Element_type;
	////
	////Array_length:
	////	Parameter_list;
	////
	////Element_type:
	////	=> Type;
	////
	////Struct_type:
	////	"struct" "{" (Field_decl SEMICOLON)* "}";
	////
	////Field_decl:
	////	(Identifier_list Type | Embedded_field) (Tag)?;
	////
	////Embedded_field:
	////	("*")+ =>Type_name;
	////
	////Tag:
	////	String_lit;
	////
	////Pointer_type:
	////	"*" Type;
	////
	////Function_type:
	////	"func" Signature;
	////
	////Signature:
	////	Parameters (=> Result)+;
	////
	////Result:
	////	Parameters | => Type;
	////
	////Parameters:
	////	"(" (Parameter_list (",")+)+ ")";
	////
	////Parameter_list:
	////	Parameter_decl  ("," Parameter_decl)*;
	////
	////Parameter_decl:
	////	(Identifier_list)? ("...")? Type;
	////
	////Interface_type:
	////	=> "interface" "{" (Method_spec SEMICOLON)* "}";
	////
	////Method_spec:
	////	IDENTIFIER Signature | Interface_type_name;
	////
	////Interface_type_name:
	////	Type_name;
	////
	////Slice_type:
	////	"[" "]" Element_type;
	////
	////Map_type:
	////	"map" "[" Key_type "]" Element_type;
	////
	////Key_type:
	////	Type;
	////
	////Channel_type:
	////	(=> "chan" | "chan" "<-" | "<-" "chan") Element_type;
	////
	////Block:
	////	"{" Statement_list "}";
	////
	////Statement_list:
	////	(Statement SEMICOLON)*;
	////
	////Declaration:
	////	Const_decl | Type_decl | Var_decl;
	////
	////Top_level_decl:
	////	Declaration | Function_decl | Method_decl;
	////
	////Const_decl:
	////	"const" Const_spec | "(" (Const_spec SEMICOLON)* ")";
	////
	////Const_spec:
	////	Identifier_list ((Type)? "=" Expression_list)?;
	////
	////Identifier_list:
	////	IDENTIFIER ("," IDENTIFIER)*;
	////
	////Expression_list:
	////	Expression ("," Expression)*;
	////
	////Type_decl:
	////	"type" (Type_spec | "(" (Type_spec SEMICOLON)* ")");
	////
	////Type_spec:
	////	Alias_decl | Type_def;
	////
	////Alias_decl:
	////	IDENTIFIER "=" Type;
	////
	////Type_def:
	////	IDENTIFIER Type;
	////
	////Var_decl:
	////	"var" (Var_spec | "(" (Var_spec SEMICOLON)* ")");
	////
	////Var_spec:
	////	Identifier_list (Type ("=" Expression_list)? | "=" Expression_list);
	////
	////Short_var_decl:
	////	=> Identifier_list ":=" Expression_list;
	////
	////Function_decl:
	////	"func" IDENTIFIER Signature (Function_body)?;
	////
	////Function_body:
	////	Block;
	////
	////Method_decl:
	////	"func" Rreciever IDENTIFIER Signature (Function_body)?;
	////
	////Rreciever:
	////	Parameters;
	////
	////Operand:
	////	Literal | Operand_name | "(" Expression ")";
	////
	////Literal:
	////	Basic_lit | Composite_lit | Function_lit;
	////
	////Basic_lit:
	////	=> Int_lit | Float_lit | Imaginary_lit | Rune_lit | String_lit;
	////
	////Operand_name:
	////	=> IDENTIFIER | Qualified_ident;
	////
	////Qualified_ident:
	////	IDENTIFIER "." IDENTIFIER;
	////
	////Composite_lit:
	////	Literal_type Literal_value;
	////
	////Literal_type:
	////	Struct_type | Array_type | "[" "..." "]" Element_type |
	////	Slice_type | Map_type | Type_name;
	////
	////Literal_value:
	////	"{" (Element_list (",")?)? "}";
	////
	////Element_list:
	////	Keyed_element ("," Keyed_element)*;
	////
	////Keyed_element:
	////	=> (Key ":")? Element;
	////
	////Key:
	////	IDENTIFIER | Expression | Literal_value;
	////
	////Element:
	////	Expression | Literal_value;
	////
	////Function_lit:
	////	"func" Signature Function_body;
	////
	////Primary_expr:
	////	Operand |
	////	Conversion |
	////	Method_expr |
	////	=> Primary_expr_selector |
	////	Primary_expr_index |
	////	Primary_expr_slice |
	////	Primary_expr_type_assertion |
	////	Primary_expr_arguments;
	////
	////Primary_expr_selector:
	////	Selector Primary_expr_selector | (=> Operand |
	////	Conversion |
	////	Method_expr);
	////
	////Primary_expr_index:
	////	Index Primary_expr_index | (=> Operand |
	////	Conversion |
	////	Method_expr);
	////
	////Primary_expr_slice:
	////	Slice Primary_expr_slice | (=> Operand |
	////	Conversion |
	////	Method_expr);
	////
	////Primary_expr_type_assertion:
	////	Type_assertion Primary_expr_type_assertion | (=> Operand |
	////	Conversion |
	////	Method_expr);
	////
	////Primary_expr_arguments:
	////	Arguments Primary_expr_arguments | (=> Operand |
	////	Conversion |
	////	Method_expr);
	////
	////Selector:
	////	"." IDENTIFIER;
	////
	////Index:
	////	"[" Expression "]";
	////
	////Slice:
	////	=> ("[" (Expression)? ":" (Expression)? "]") | ("[" (Expression)? ":" Expression ":" Expression "]");
	////
	////Type_assertion:
	////	"." "(" Type ")";
	////
	////Arguments:
	////	"(" (=> Expression_list | Type ("," Expression_list)? ("...")? (",")?)? ")";
	////
	////Method_expr:
	////	Reciever_type "." IDENTIFIER;
	////
	////Reciever_type:
	////	Type;
	////
	////Expression:
	////	Unary_expr Expression_line;
	////
	////Expression_line:
	////	BINARY_OP Expression Expression_line;
	////
	////Unary_expr:
	////	(Primary_expr | UNARY_OP)+;
	////
	////Conversion:
	////	Type "(" Expression (",")? ")";
	////
	////Statement:
	////	Declaration | Labeled_stmt | Simple_stmt | Go_stmt | Return_stmt |
	////	Break_stmt | Continue_stmt | Goto_stmt |
	////	"fallthrough" | Block | If_stmt | Switch_stmt |
	////	Select_stmt | For_stmt | Defer_stmt;
	////
	////Simple_stmt:
	////	Empty_stmt | Expression_stmt | Send_stmt | Inc_dec_stmt | Assignment | Short_var_decl;
	////
	////Empty_stmt:
	////	WS;
	////
	////Labeled_stmt:
	////	=> IDENTIFIER ":" Statement;
	////
	////Expression_stmt:
	////	Expression;
	////
	////Send_stmt:
	////	=> Channel "<-" Expression;
	////
	////Channel:
	////	Expression;
	////
	////Inc_dec_stmt:
	////	=> Expression ("++" | "--");
	////
	////Assignment:
	////	=> Expression_list ASSIGN_OP Expression_list;
	////
	////If_stmt:
	////	"if" (Simple_stmt SEMICOLON)? => Expression Block ("else" (If_stmt | Block))?;
	////
	////Switch_stmt:
	////	=> Expr_switch_stmt | Type_switch_stmt;
	////
	////Expr_switch_stmt:
	////	"switch" (Simple_stmt SEMICOLON)? => (Expression)? "{" (Expr_case_clause)* "}";
	////
	////Expr_case_clause:
	////	Expr_switch_case ":" Statement_list;
	////
	////Expr_switch_case:
	////	"case" Expression_list | "default";
	////
	////Type_switch_stmt:
	////	"switch" (Simple_stmt SEMICOLON)? => Type_switch_guard "{" (Type_case_clause)* "}";
	////
	////Type_switch_guard:
	////	(IDENTIFIER ":=")? Primary_expr "." "(" "type" ")";
	////
	////Type_case_clause:
	////	Type_switch_case ":" Statement_list;
	////
	////Type_switch_case:
	////	"case" Type_list | "default";
	////
	////Type_list:
	////	Type ("," Type)*;
	////
	////For_stmt:
	////	"for" (=> Condition | For_clause | Range_clause)? Block;
	////
	////Condition:
	////	Expression;
	////
	////For_clause:
	////	(Init_stmt)? SEMICOLON (Condition)? SEMICOLON (Post_stmt)?;
	////
	////Init_stmt:
	////	Simple_stmt;
	////
	////Post_stmt:
	////	Simple_stmt;
	////
	////Range_clause:
	////	(Expression_list "=" | Identifier_list ":=")? "range" Expression;
	////
	////Go_stmt:
	////	"go" Expression;
	////
	////Select_stmt:
	////	"select" "{" (Comm_clause)* "}";
	////
	////Comm_clause:
	////	Comm_case ":" Statement_list;
	////
	////Comm_case:
	////	"case" (Send_stmt | Recv_stmt) | "default";
	////
	////Recv_stmt:
	////	(=> Expression_list "=" | Identifier_list ":=")? Recv_expr;
	////
	////Recv_expr:
	////	Expression;
	////
	////Return_stmt:
	////	"return" (Expression_list)?;
	////
	////Break_stmt:
	////	"break" (IDENTIFIER)?;
	////
	////Continue_stmt:
	////	"continue" (IDENTIFIER)?;
	////
	////Goto_stmt:
	////	"goto" IDENTIFIER;
	////
	////Defer_stmt:
	////	"defer" Expression;
	////
	////Source_file:
	////	Package_clause SEMICOLON (Import_decl SEMICOLON)* (Top_level_decl SEMICOLON)*;
	////
	////Package_clause:
	////	"package" IDENTIFIER;
	////
	//Import_decl:
	//	"import" (Import_spec | "(" (Import_spec SEMICOLON)* ")");
	public Import_declElements getImport_declAccess() {
		return pImport_decl;
	}
	
	public ParserRule getImport_declRule() {
		return getImport_declAccess().getRule();
	}
	
	//Import_spec:
	//	("." | Identifier_Unicode_Value)? String_lit;
	public Import_specElements getImport_specAccess() {
		return pImport_spec;
	}
	
	public ParserRule getImport_specRule() {
		return getImport_specAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
