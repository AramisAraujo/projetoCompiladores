/*
 * generated by Xtext 2.14.0
 */
package org.xtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class GoGrammarAccess extends AbstractGrammarElementFinder {
	
	public class ModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Model");
		private final Assignment cGreetingsAssignment = (Assignment)rule.eContents().get(1);
		private final Keyword cGreetingsOiKeyword_0 = (Keyword)cGreetingsAssignment.eContents().get(0);
		
		//Model:
		//	greetings+="oi";
		@Override public ParserRule getRule() { return rule; }
		
		//greetings+="oi"
		public Assignment getGreetingsAssignment() { return cGreetingsAssignment; }
		
		//"oi"
		public Keyword getGreetingsOiKeyword_0() { return cGreetingsOiKeyword_0; }
	}
	public class OPERATORSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.OPERATORS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBINARY_OPTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cLeftSquareBracketKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cAlternatives.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cAlternatives.eContents().get(5);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cAlternatives.eContents().get(6);
		private final Keyword cPlusSignPlusSignKeyword_7 = (Keyword)cAlternatives.eContents().get(7);
		private final Keyword cEqualsSignKeyword_8 = (Keyword)cAlternatives.eContents().get(8);
		private final Keyword cColonEqualsSignKeyword_9 = (Keyword)cAlternatives.eContents().get(9);
		private final Keyword cCommaKeyword_10 = (Keyword)cAlternatives.eContents().get(10);
		private final RuleCall cSEMICOLONTerminalRuleCall_11 = (RuleCall)cAlternatives.eContents().get(11);
		private final Keyword cHyphenMinusHyphenMinusKeyword_12 = (Keyword)cAlternatives.eContents().get(12);
		private final Keyword cFullStopFullStopFullStopKeyword_13 = (Keyword)cAlternatives.eContents().get(13);
		private final Keyword cFullStopKeyword_14 = (Keyword)cAlternatives.eContents().get(14);
		private final Keyword cColonKeyword_15 = (Keyword)cAlternatives.eContents().get(15);
		private final RuleCall cASSIGN_OPTerminalRuleCall_16 = (RuleCall)cAlternatives.eContents().get(16);
		
		//fragment OPERATORS:
		//	BINARY_OP | '(' | ')' | '[' | ']' |
		//	'{' | '}' | '++' | '=' | ':=' | ',' | SEMICOLON |
		//	'--' | '...' | '.' | ':' | ASSIGN_OP;
		@Override public ParserRule getRule() { return rule; }
		
		//BINARY_OP | '(' | ')' | '[' | ']' | '{' | '}' | '++' | '=' | ':=' | ',' | SEMICOLON | '--' | '...' | '.' | ':' |
		//ASSIGN_OP
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BINARY_OP
		public RuleCall getBINARY_OPTerminalRuleCall_0() { return cBINARY_OPTerminalRuleCall_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//')'
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_3() { return cLeftSquareBracketKeyword_3; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
		
		//'++'
		public Keyword getPlusSignPlusSignKeyword_7() { return cPlusSignPlusSignKeyword_7; }
		
		//'='
		public Keyword getEqualsSignKeyword_8() { return cEqualsSignKeyword_8; }
		
		//':='
		public Keyword getColonEqualsSignKeyword_9() { return cColonEqualsSignKeyword_9; }
		
		//','
		public Keyword getCommaKeyword_10() { return cCommaKeyword_10; }
		
		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_11() { return cSEMICOLONTerminalRuleCall_11; }
		
		//'--'
		public Keyword getHyphenMinusHyphenMinusKeyword_12() { return cHyphenMinusHyphenMinusKeyword_12; }
		
		//'...'
		public Keyword getFullStopFullStopFullStopKeyword_13() { return cFullStopFullStopFullStopKeyword_13; }
		
		//'.'
		public Keyword getFullStopKeyword_14() { return cFullStopKeyword_14; }
		
		//':'
		public Keyword getColonKeyword_15() { return cColonKeyword_15; }
		
		//ASSIGN_OP
		public RuleCall getASSIGN_OPTerminalRuleCall_16() { return cASSIGN_OPTerminalRuleCall_16; }
	}
	public class Int_litElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Int_lit");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cOCTAL_LITTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cHEX_LITTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//////	'\\u0030'..'\\u0039' | '\\u0660'..'\\u0669' | '\\u06F0'..'\\u06F9' | '\\u07C0'..'\\u07C9' | '\\u0966'..'\\u096F' |
		//////	'\\u09E6'..'\\u09EF' | '\\u0A66'..'\\u0A6F' | '\\u0AE6'..'\\u0AEF' | '\\u0B66'..'\\u0B6F' | '\\u0BE6'..'\\u0BEF' |
		//////	'\\u0C66'..'\\u0C6F' | '\\u0CE6'..'\\u0CEF' | '\\u0D66'..'\\u0D6F' | '\\u0DE6'..'\\u0DEF' | '\\u0E50'..'\\u0E59' |
		//////	'\\u0ED0'..'\\u0ED9' | '\\u0F20'..'\\u0F29' | '\\u1040'..'\\u1049' | '\\u1090'..'\\u1099' | '\\u17E0'..'\\u17E9' |
		//////	'\\u1810'..'\\u1819' | '\\u1946'..'\\u194F' | '\\u19D0'..'\\u19D9' | '\\u1A80'..'\\u1A89' | '\\u1A90'..'\\u1A99' |
		//////	'\\u1B50'..'\\u1B59' | '\\u1BB0'..'\\u1BB9' | '\\u1C40'..'\\u1C49' | '\\u1C50'..'\\u1C59' | '\\uA620'..'\\uA629' |
		//////	'\\uA8D0'..'\\uA8D9' | '\\uA900'..'\\uA909' | '\\uA9D0'..'\\uA9D9' | '\\uA9F0'..'\\uA9F9' | '\\uAA50'..'\\uAA59' |
		//////	'\\uABF0'..'\\uABF9' | '\\uFF10'..'\\uFF19';
		////
		////
		//Int_lit:
		//	INT | OCTAL_LIT | HEX_LIT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT | OCTAL_LIT | HEX_LIT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//OCTAL_LIT
		public RuleCall getOCTAL_LITTerminalRuleCall_1() { return cOCTAL_LITTerminalRuleCall_1; }
		
		//HEX_LIT
		public RuleCall getHEX_LITTerminalRuleCall_2() { return cHEX_LITTerminalRuleCall_2; }
	}
	public class Float_litElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Float_lit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Group cGroup_1_0 = (Group)cAlternatives_1.eContents().get(0);
		private final Keyword cFullStopKeyword_1_0_0 = (Keyword)cGroup_1_0.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1_0_1 = (RuleCall)cGroup_1_0.eContents().get(1);
		private final RuleCall cExponentParserRuleCall_1_0_2 = (RuleCall)cGroup_1_0.eContents().get(2);
		private final RuleCall cExponentParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final Keyword cFullStopKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cINTTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final RuleCall cExponentParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		//Float_lit:
		//	INT ('.' INT? Exponent? | Exponent)
		//	'.' INT Exponent?;
		@Override public ParserRule getRule() { return rule; }
		
		//INT ('.' INT? Exponent? | Exponent) '.' INT Exponent?
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//'.' INT? Exponent? | Exponent
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'.' INT? Exponent?
		public Group getGroup_1_0() { return cGroup_1_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1_0_0() { return cFullStopKeyword_1_0_0; }
		
		//INT?
		public RuleCall getINTTerminalRuleCall_1_0_1() { return cINTTerminalRuleCall_1_0_1; }
		
		//Exponent?
		public RuleCall getExponentParserRuleCall_1_0_2() { return cExponentParserRuleCall_1_0_2; }
		
		//Exponent
		public RuleCall getExponentParserRuleCall_1_1() { return cExponentParserRuleCall_1_1; }
		
		//'.'
		public Keyword getFullStopKeyword_2() { return cFullStopKeyword_2; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_3() { return cINTTerminalRuleCall_3; }
		
		//Exponent?
		public RuleCall getExponentParserRuleCall_4() { return cExponentParserRuleCall_4; }
	}
	public class ExponentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Exponent");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cEKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cEKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_0 = (Keyword)cAlternatives_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_1 = (Keyword)cAlternatives_1.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Exponent:
		//	('E' | 'e') ('+' | '-')? INT;
		@Override public ParserRule getRule() { return rule; }
		
		//('E' | 'e') ('+' | '-')? INT
		public Group getGroup() { return cGroup; }
		
		//'E' | 'e'
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'E'
		public Keyword getEKeyword_0_0() { return cEKeyword_0_0; }
		
		//'e'
		public Keyword getEKeyword_0_1() { return cEKeyword_0_1; }
		
		//('+' | '-')?
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//'+'
		public Keyword getPlusSignKeyword_1_0() { return cPlusSignKeyword_1_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1_1() { return cHyphenMinusKeyword_1_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}
	public class Imaginary_litElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Imaginary_lit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_0_0 = (RuleCall)cAlternatives_0.eContents().get(0);
		private final RuleCall cFloat_litParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final Keyword cIKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Imaginary_lit:
		//	(INT | Float_lit) 'i';
		@Override public ParserRule getRule() { return rule; }
		
		//(INT | Float_lit) 'i'
		public Group getGroup() { return cGroup; }
		
		//INT | Float_lit
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0_0() { return cINTTerminalRuleCall_0_0; }
		
		//Float_lit
		public RuleCall getFloat_litParserRuleCall_0_1() { return cFloat_litParserRuleCall_0_1; }
		
		//'i'
		public Keyword getIKeyword_1() { return cIKeyword_1; }
	}
	public class Rune_litElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Rune_lit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cApostropheKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cUNICODE_VALUETerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cByte_valueParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final Keyword cApostropheKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Rune_lit:
		//	"'" (UNICODE_VALUE | Byte_value) "'";
		@Override public ParserRule getRule() { return rule; }
		
		//"'" (UNICODE_VALUE | Byte_value) "'"
		public Group getGroup() { return cGroup; }
		
		//"'"
		public Keyword getApostropheKeyword_0() { return cApostropheKeyword_0; }
		
		//UNICODE_VALUE | Byte_value
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//UNICODE_VALUE
		public RuleCall getUNICODE_VALUETerminalRuleCall_1_0() { return cUNICODE_VALUETerminalRuleCall_1_0; }
		
		//Byte_value
		public RuleCall getByte_valueParserRuleCall_1_1() { return cByte_valueParserRuleCall_1_1; }
		
		//"'"
		public Keyword getApostropheKeyword_2() { return cApostropheKeyword_2; }
	}
	public class Byte_valueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Byte_value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cOCTAL_BYTE_VALUETerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cHEX_BYTE_VALUETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Byte_value:
		//	OCTAL_BYTE_VALUE | HEX_BYTE_VALUE;
		@Override public ParserRule getRule() { return rule; }
		
		//OCTAL_BYTE_VALUE | HEX_BYTE_VALUE
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//OCTAL_BYTE_VALUE
		public RuleCall getOCTAL_BYTE_VALUETerminalRuleCall_0() { return cOCTAL_BYTE_VALUETerminalRuleCall_0; }
		
		//HEX_BYTE_VALUE
		public RuleCall getHEX_BYTE_VALUETerminalRuleCall_1() { return cHEX_BYTE_VALUETerminalRuleCall_1; }
	}
	public class String_litElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.String_lit");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRAW_STRING_LITTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cInterpreted_string_litParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//String_lit:
		//	RAW_STRING_LIT | Interpreted_string_lit;
		@Override public ParserRule getRule() { return rule; }
		
		//RAW_STRING_LIT | Interpreted_string_lit
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//RAW_STRING_LIT
		public RuleCall getRAW_STRING_LITTerminalRuleCall_0() { return cRAW_STRING_LITTerminalRuleCall_0; }
		
		//Interpreted_string_lit
		public RuleCall getInterpreted_string_litParserRuleCall_1() { return cInterpreted_string_litParserRuleCall_1; }
	}
	public class Interpreted_string_litElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Interpreted_string_lit");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cQuotationMarkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cUNICODE_VALUETerminalRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final RuleCall cByte_valueParserRuleCall_1_1 = (RuleCall)cAlternatives_1.eContents().get(1);
		private final Keyword cQuotationMarkKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Interpreted_string_lit:
		//	'"' (UNICODE_VALUE | Byte_value)* '"';
		@Override public ParserRule getRule() { return rule; }
		
		//'"' (UNICODE_VALUE | Byte_value)* '"'
		public Group getGroup() { return cGroup; }
		
		//'"'
		public Keyword getQuotationMarkKeyword_0() { return cQuotationMarkKeyword_0; }
		
		//(UNICODE_VALUE | Byte_value)*
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//UNICODE_VALUE
		public RuleCall getUNICODE_VALUETerminalRuleCall_1_0() { return cUNICODE_VALUETerminalRuleCall_1_0; }
		
		//Byte_value
		public RuleCall getByte_valueParserRuleCall_1_1() { return cByte_valueParserRuleCall_1_1; }
		
		//'"'
		public Keyword getQuotationMarkKeyword_2() { return cQuotationMarkKeyword_2; }
	}
	public class LiteralsElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Literals");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cInt_litParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cFloat_litParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cImaginary_litParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cRune_litParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cString_litParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//Literals:
		//	Int_lit | Float_lit | Imaginary_lit | Rune_lit | String_lit;
		@Override public ParserRule getRule() { return rule; }
		
		//Int_lit | Float_lit | Imaginary_lit | Rune_lit | String_lit
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Int_lit
		public RuleCall getInt_litParserRuleCall_0() { return cInt_litParserRuleCall_0; }
		
		//Float_lit
		public RuleCall getFloat_litParserRuleCall_1() { return cFloat_litParserRuleCall_1; }
		
		//Imaginary_lit
		public RuleCall getImaginary_litParserRuleCall_2() { return cImaginary_litParserRuleCall_2; }
		
		//Rune_lit
		public RuleCall getRune_litParserRuleCall_3() { return cRune_litParserRuleCall_3; }
		
		//String_lit
		public RuleCall getString_litParserRuleCall_4() { return cString_litParserRuleCall_4; }
	}
	public class CommentElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Comment");
		private final RuleCall cML_COMMENTTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Comment:
		//	ML_COMMENT;
		@Override public ParserRule getRule() { return rule; }
		
		//ML_COMMENT
		public RuleCall getML_COMMENTTerminalRuleCall() { return cML_COMMENTTerminalRuleCall; }
	}
	public class TokenElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Token");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDENTIFIERTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKEYWORDSTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cOPERATORSParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLiteralsParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//Token:
		//	IDENTIFIER | KEYWORDS | OPERATORS | Literals;
		@Override public ParserRule getRule() { return rule; }
		
		//IDENTIFIER | KEYWORDS | OPERATORS | Literals
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall_0() { return cIDENTIFIERTerminalRuleCall_0; }
		
		//KEYWORDS
		public RuleCall getKEYWORDSTerminalRuleCall_1() { return cKEYWORDSTerminalRuleCall_1; }
		
		//OPERATORS
		public RuleCall getOPERATORSParserRuleCall_2() { return cOPERATORSParserRuleCall_2; }
		
		//Literals
		public RuleCall getLiteralsParserRuleCall_3() { return cLiteralsParserRuleCall_3; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Type");
		private final RuleCall cType_nameParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Type:
		//	Type_name;
		@Override public ParserRule getRule() { return rule; }
		
		//Type_name
		public RuleCall getType_nameParserRuleCall() { return cType_nameParserRuleCall; }
	}
	public class Type_nameElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Type_name");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cIDENTIFIERTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cQualified_identParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		////| Type_lit | "(" Type ")";
		//Type_name:
		//	IDENTIFIER | Qualified_ident;
		@Override public ParserRule getRule() { return rule; }
		
		//IDENTIFIER | Qualified_ident
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall_0() { return cIDENTIFIERTerminalRuleCall_0; }
		
		//Qualified_ident
		public RuleCall getQualified_identParserRuleCall_1() { return cQualified_identParserRuleCall_1; }
	}
	public class Type_litElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Type_lit");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArray_typeParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStruct_typeParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cPointer_typeParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//Type_lit:
		//	Array_type | Struct_type | Pointer_type;
		@Override public ParserRule getRule() { return rule; }
		
		//Array_type | Struct_type | Pointer_type
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Array_type
		public RuleCall getArray_typeParserRuleCall_0() { return cArray_typeParserRuleCall_0; }
		
		//Struct_type
		public RuleCall getStruct_typeParserRuleCall_1() { return cStruct_typeParserRuleCall_1; }
		
		//Pointer_type
		public RuleCall getPointer_typeParserRuleCall_2() { return cPointer_typeParserRuleCall_2; }
	}
	public class Array_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Array_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cParameter_listParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cRightSquareBracketKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final RuleCall cTypeParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		////| Function_type |
		////Interface_type | Slice_type | Map_type | Channel_type;
		//Array_type:
		//	"[" Parameter_list "]" Type;
		@Override public ParserRule getRule() { return rule; }
		
		//"[" Parameter_list "]" Type
		public Group getGroup() { return cGroup; }
		
		//"["
		public Keyword getLeftSquareBracketKeyword_0() { return cLeftSquareBracketKeyword_0; }
		
		//Parameter_list
		public RuleCall getParameter_listParserRuleCall_1() { return cParameter_listParserRuleCall_1; }
		
		//"]"
		public Keyword getRightSquareBracketKeyword_2() { return cRightSquareBracketKeyword_2; }
		
		//Type
		public RuleCall getTypeParserRuleCall_3() { return cTypeParserRuleCall_3; }
	}
	public class Struct_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Struct_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cStructKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cField_declParserRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		////Array_length:
		////	Parameter_list;
		////
		////Element_type:
		////	Type;
		//Struct_type:
		//	"struct" "{" (Field_decl SEMICOLON)* "}";
		@Override public ParserRule getRule() { return rule; }
		
		//"struct" "{" (Field_decl SEMICOLON)* "}"
		public Group getGroup() { return cGroup; }
		
		//"struct"
		public Keyword getStructKeyword_0() { return cStructKeyword_0; }
		
		//"{"
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//(Field_decl SEMICOLON)*
		public Group getGroup_2() { return cGroup_2; }
		
		//Field_decl
		public RuleCall getField_declParserRuleCall_2_0() { return cField_declParserRuleCall_2_0; }
		
		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_2_1() { return cSEMICOLONTerminalRuleCall_2_1; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class Field_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Field_decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Group cGroup_0_0 = (Group)cAlternatives_0.eContents().get(0);
		private final RuleCall cIdentifier_listParserRuleCall_0_0_0 = (RuleCall)cGroup_0_0.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_0_0_1 = (RuleCall)cGroup_0_0.eContents().get(1);
		private final RuleCall cEmbedded_fieldParserRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cString_litParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Field_decl:
		//	(Identifier_list Type | Embedded_field) String_lit?;
		@Override public ParserRule getRule() { return rule; }
		
		//(Identifier_list Type | Embedded_field) String_lit?
		public Group getGroup() { return cGroup; }
		
		//Identifier_list Type | Embedded_field
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//Identifier_list Type
		public Group getGroup_0_0() { return cGroup_0_0; }
		
		//Identifier_list
		public RuleCall getIdentifier_listParserRuleCall_0_0_0() { return cIdentifier_listParserRuleCall_0_0_0; }
		
		//Type
		public RuleCall getTypeParserRuleCall_0_0_1() { return cTypeParserRuleCall_0_0_1; }
		
		//Embedded_field
		public RuleCall getEmbedded_fieldParserRuleCall_0_1() { return cEmbedded_fieldParserRuleCall_0_1; }
		
		//String_lit?
		public RuleCall getString_litParserRuleCall_1() { return cString_litParserRuleCall_1; }
	}
	public class Embedded_fieldElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Embedded_field");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAsteriskKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cType_nameParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Embedded_field:
		//	"*"+ Type_name;
		@Override public ParserRule getRule() { return rule; }
		
		//"*"+ Type_name
		public Group getGroup() { return cGroup; }
		
		//"*"+
		public Keyword getAsteriskKeyword_0() { return cAsteriskKeyword_0; }
		
		//Type_name
		public RuleCall getType_nameParserRuleCall_1() { return cType_nameParserRuleCall_1; }
	}
	public class Pointer_typeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Pointer_type");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cAsteriskKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cTypeParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		////Tag:
		////	String_lit;
		////
		//Pointer_type:
		//	"*" Type;
		@Override public ParserRule getRule() { return rule; }
		
		//"*" Type
		public Group getGroup() { return cGroup; }
		
		//"*"
		public Keyword getAsteriskKeyword_0() { return cAsteriskKeyword_0; }
		
		//Type
		public RuleCall getTypeParserRuleCall_1() { return cTypeParserRuleCall_1; }
	}
	public class ParametersElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Parameters");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cParameter_listParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cCommaKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		////Function_type:
		////	"func" Signature;
		////
		////Signature:
		////	Parameters (Parameters | Type)+;
		//Parameters:
		//	"(" (Parameter_list ","+)+ ")";
		@Override public ParserRule getRule() { return rule; }
		
		//"(" (Parameter_list ","+)+ ")"
		public Group getGroup() { return cGroup; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_0() { return cLeftParenthesisKeyword_0; }
		
		//(Parameter_list ","+)+
		public Group getGroup_1() { return cGroup_1; }
		
		//Parameter_list
		public RuleCall getParameter_listParserRuleCall_1_0() { return cParameter_listParserRuleCall_1_0; }
		
		//","+
		public Keyword getCommaKeyword_1_1() { return cCommaKeyword_1_1; }
		
		//")"
		public Keyword getRightParenthesisKeyword_2() { return cRightParenthesisKeyword_2; }
	}
	public class Parameter_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Parameter_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cParameter_declParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cParameter_declParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		//Parameter_list:
		//	Parameter_decl ("," Parameter_decl)*;
		@Override public ParserRule getRule() { return rule; }
		
		//Parameter_decl ("," Parameter_decl)*
		public Group getGroup() { return cGroup; }
		
		//Parameter_decl
		public RuleCall getParameter_declParserRuleCall_0() { return cParameter_declParserRuleCall_0; }
		
		//("," Parameter_decl)*
		public Group getGroup_1() { return cGroup_1; }
		
		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//Parameter_decl
		public RuleCall getParameter_declParserRuleCall_1_1() { return cParameter_declParserRuleCall_1_1; }
	}
	public class Parameter_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Parameter_decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final RuleCall cIdentifier_listParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Keyword cFullStopFullStopFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cTypeParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//Parameter_decl: //{Identifier , Identifier} should be derivated through identifier_list
		//// and type before Identifier_list alone
		//	=> (Identifier_list)? "..."? Type;
		@Override public ParserRule getRule() { return rule; }
		
		////{Identifier , Identifier} should be derivated through identifier_list
		//// and type before Identifier_list alone
		//=> (Identifier_list)? "..."? Type
		public Group getGroup() { return cGroup; }
		
		////{Identifier , Identifier} should be derivated through identifier_list
		//// and type before Identifier_list alone
		//=> (Identifier_list)?
		public Group getGroup_0() { return cGroup_0; }
		
		//Identifier_list
		public RuleCall getIdentifier_listParserRuleCall_0_0() { return cIdentifier_listParserRuleCall_0_0; }
		
		//"..."?
		public Keyword getFullStopFullStopFullStopKeyword_1() { return cFullStopFullStopFullStopKeyword_1; }
		
		//Type
		public RuleCall getTypeParserRuleCall_2() { return cTypeParserRuleCall_2; }
	}
	public class Identifier_listElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Identifier_list");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDENTIFIERTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cCommaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cIDENTIFIERTerminalRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		
		////Interface_type:
		////	=> "interface" "{" (Method_spec SEMICOLON)* "}";
		////
		////Method_spec:
		////	IDENTIFIER Signature | Interface_type_name;
		////
		////Interface_type_name:
		////	Type_name;
		////
		////Slice_type:
		////	"[" "]" Element_type;
		////
		////Map_type:
		////	"map" "[" Key_type "]" Element_type;
		////
		////Key_type:
		////	Type;
		////
		////Channel_type:
		////	(=> "chan" | "chan" "<-" | "<-" "chan") Element_type;
		////
		////Block:
		////	"{" Statement_list "}";
		////
		////Statement_list:
		////	(Statement SEMICOLON)*;
		////
		////Declaration:
		////	Const_decl | Type_decl | Var_decl;
		////
		////Top_level_decl:
		////	Declaration | Function_decl | Method_decl;
		////
		////Const_decl:
		////	"const" Const_spec | "(" (Const_spec SEMICOLON)* ")";
		////
		////Const_spec:
		////	Identifier_list ((Type)? "=" Expression_list)?;
		////
		//Identifier_list:
		//	IDENTIFIER ("," IDENTIFIER)*;
		@Override public ParserRule getRule() { return rule; }
		
		//IDENTIFIER ("," IDENTIFIER)*
		public Group getGroup() { return cGroup; }
		
		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall_0() { return cIDENTIFIERTerminalRuleCall_0; }
		
		//("," IDENTIFIER)*
		public Group getGroup_1() { return cGroup_1; }
		
		//","
		public Keyword getCommaKeyword_1_0() { return cCommaKeyword_1_0; }
		
		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall_1_1() { return cIDENTIFIERTerminalRuleCall_1_1; }
	}
	public class Qualified_identElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Qualified_ident");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDENTIFIERTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cIDENTIFIERTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		////Expression_list:
		////	Expression ("," Expression)*;
		////
		////Type_decl:
		////	"type" (Type_spec | "(" (Type_spec SEMICOLON)* ")");
		////
		////Type_spec:
		////	Alias_decl | Type_def;
		////
		////Alias_decl:
		////	IDENTIFIER "=" Type;
		////
		////Type_def:
		////	IDENTIFIER Type;
		////
		////Var_decl:
		////	"var" (Var_spec | "(" (Var_spec SEMICOLON)* ")");
		////
		////Var_spec:
		////	Identifier_list (Type ("=" Expression_list)? | "=" Expression_list);
		////
		////Short_var_decl:
		////	=> Identifier_list ":=" Expression_list;
		////
		////Function_decl:
		////	"func" IDENTIFIER Signature (Function_body)?;
		////
		////Function_body:
		////	Block;
		////
		////Method_decl:
		////	"func" Rreciever IDENTIFIER Signature (Function_body)?;
		////
		////Rreciever:
		////	Parameters;
		////
		////Operand:
		////	Literal | Operand_name | "(" Expression ")";
		////
		////Literal:
		////	Basic_lit | Composite_lit | Function_lit;
		////
		////Basic_lit:
		////	=> Int_lit | Float_lit | Imaginary_lit | Rune_lit | String_lit;
		////
		////Operand_name:
		////	=> IDENTIFIER | Qualified_ident;
		////
		//Qualified_ident:
		//	IDENTIFIER "." IDENTIFIER;
		@Override public ParserRule getRule() { return rule; }
		
		//IDENTIFIER "." IDENTIFIER
		public Group getGroup() { return cGroup; }
		
		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall_0() { return cIDENTIFIERTerminalRuleCall_0; }
		
		//"."
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall_2() { return cIDENTIFIERTerminalRuleCall_2; }
	}
	public class Empty_stmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Empty_stmt");
		private final RuleCall cWSTerminalRuleCall = (RuleCall)rule.eContents().get(1);
		
		////Composite_lit:
		////	Literal_type Literal_value;
		////
		////Literal_type:
		////	Struct_type | Array_type | "[" "..." "]" Element_type |
		////	Slice_type | Map_type | Type_name;
		////
		////Literal_value:
		////	"{" (Element_list (",")?)? "}";
		////
		////Element_list:
		////	Keyed_element ("," Keyed_element)*;
		////
		////Keyed_element:
		////	=> (Key ":")? Element;
		////
		////Key:
		////	IDENTIFIER | Expression | Literal_value;
		////
		////Element:
		////	Expression | Literal_value;
		////
		////Function_lit:
		////	"func" Signature Function_body;
		////
		////Primary_expr:
		////	Operand |
		////	Conversion |
		////	Method_expr |
		////	=> Primary_expr_selector |
		////	Primary_expr_index |
		////	Primary_expr_slice |
		////	Primary_expr_type_assertion |
		////	Primary_expr_arguments;
		////
		////Primary_expr_selector:
		////	Selector Primary_expr_selector | (=> Operand |
		////	Conversion |
		////	Method_expr);
		////
		////Primary_expr_index:
		////	Index Primary_expr_index | (=> Operand |
		////	Conversion |
		////	Method_expr);
		////
		////Primary_expr_slice:
		////	Slice Primary_expr_slice | (=> Operand |
		////	Conversion |
		////	Method_expr);
		////
		////Primary_expr_type_assertion:
		////	Type_assertion Primary_expr_type_assertion | (=> Operand |
		////	Conversion |
		////	Method_expr);
		////
		////Primary_expr_arguments:
		////	Arguments Primary_expr_arguments | (=> Operand |
		////	Conversion |
		////	Method_expr);
		////
		////Selector:
		////	"." IDENTIFIER;
		////
		////Index:
		////	"[" Expression "]";
		////
		////Slice:
		////	=> ("[" (Expression)? ":" (Expression)? "]") | ("[" (Expression)? ":" Expression ":" Expression "]");
		////
		////Type_assertion:
		////	"." "(" Type ")";
		////
		////Arguments:
		////	"(" (=> Expression_list | Type ("," Expression_list)? ("...")? (",")?)? ")";
		////
		////Method_expr:
		////	Reciever_type "." IDENTIFIER;
		////
		////Reciever_type:
		////	Type;
		////
		////Expression:
		////	Unary_expr Expression_line;
		////
		////Expression_line:
		////	BINARY_OP Expression Expression_line;
		////
		////Unary_expr:
		////	(Primary_expr | UNARY_OP)+;
		////
		////Conversion:
		////	Type "(" Expression (",")? ")";
		////
		////Statement:
		////	Declaration | Labeled_stmt | Simple_stmt | Go_stmt | Return_stmt |
		////	Break_stmt | Continue_stmt | Goto_stmt |
		////	"fallthrough" | Block | If_stmt | Switch_stmt |
		////	Select_stmt | For_stmt | Defer_stmt;
		////
		////Simple_stmt:
		////	Empty_stmt | Expression_stmt | Send_stmt | Inc_dec_stmt | Assignment | Short_var_decl;
		////
		//Empty_stmt:
		//	WS;
		@Override public ParserRule getRule() { return rule; }
		
		//WS
		public RuleCall getWSTerminalRuleCall() { return cWSTerminalRuleCall; }
	}
	public class Break_stmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Break_stmt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cBreakKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cIDENTIFIERTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		////Labeled_stmt:
		////	=> IDENTIFIER ":" Statement;
		////
		////Expression_stmt:
		////	Expression;
		////
		////Send_stmt:
		////	=> Channel "<-" Expression;
		////
		////Channel:
		////	Expression;
		////
		////Inc_dec_stmt:
		////	=> Expression ("++" | "--");
		////
		////Assignment:
		////	=> Expression_list ASSIGN_OP Expression_list;
		////
		////If_stmt:
		////	"if" (Simple_stmt SEMICOLON)? => Expression Block ("else" (If_stmt | Block))?;
		////
		////Switch_stmt:
		////	=> Expr_switch_stmt | Type_switch_stmt;
		////
		////Expr_switch_stmt:
		////	"switch" (Simple_stmt SEMICOLON)? => (Expression)? "{" (Expr_case_clause)* "}";
		////
		////Expr_case_clause:
		////	Expr_switch_case ":" Statement_list;
		////
		////Expr_switch_case:
		////	"case" Expression_list | "default";
		////
		////Type_switch_stmt:
		////	"switch" (Simple_stmt SEMICOLON)? => Type_switch_guard "{" (Type_case_clause)* "}";
		////
		////Type_switch_guard:
		////	(IDENTIFIER ":=")? Primary_expr "." "(" "type" ")";
		////
		////Type_case_clause:
		////	Type_switch_case ":" Statement_list;
		////
		////Type_switch_case:
		////	"case" Type_list | "default";
		////
		////Type_list:
		////	Type ("," Type)*;
		////
		////For_stmt:
		////	"for" (=> Condition | For_clause | Range_clause)? Block;
		////
		////Condition:
		////	Expression;
		////
		////For_clause:
		////	(Init_stmt)? SEMICOLON (Condition)? SEMICOLON (Post_stmt)?;
		////
		////Init_stmt:
		////	Simple_stmt;
		////
		////Post_stmt:
		////	Simple_stmt;
		////
		////Range_clause:
		////	(Expression_list "=" | Identifier_list ":=")? "range" Expression;
		////
		////Go_stmt:
		////	"go" Expression;
		////
		////Select_stmt:
		////	"select" "{" (Comm_clause)* "}";
		////
		////Comm_clause:
		////	Comm_case ":" Statement_list;
		////
		////Comm_case:
		////	"case" (Send_stmt | Recv_stmt) | "default";
		////
		////Recv_stmt:
		////	(=> Expression_list "=" | Identifier_list ":=")? Recv_expr;
		////
		////Recv_expr:
		////	Expression;
		////
		////Return_stmt:
		////	"return" (Expression_list)?;
		////
		//Break_stmt:
		//	"break" IDENTIFIER?;
		@Override public ParserRule getRule() { return rule; }
		
		//"break" IDENTIFIER?
		public Group getGroup() { return cGroup; }
		
		//"break"
		public Keyword getBreakKeyword_0() { return cBreakKeyword_0; }
		
		//IDENTIFIER?
		public RuleCall getIDENTIFIERTerminalRuleCall_1() { return cIDENTIFIERTerminalRuleCall_1; }
	}
	public class Continue_stmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Continue_stmt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cContinueKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cIDENTIFIERTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Continue_stmt:
		//	"continue" IDENTIFIER?;
		@Override public ParserRule getRule() { return rule; }
		
		//"continue" IDENTIFIER?
		public Group getGroup() { return cGroup; }
		
		//"continue"
		public Keyword getContinueKeyword_0() { return cContinueKeyword_0; }
		
		//IDENTIFIER?
		public RuleCall getIDENTIFIERTerminalRuleCall_1() { return cIDENTIFIERTerminalRuleCall_1; }
	}
	public class Goto_stmtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Goto_stmt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cGotoKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cIDENTIFIERTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Goto_stmt:
		//	"goto" IDENTIFIER;
		@Override public ParserRule getRule() { return rule; }
		
		//"goto" IDENTIFIER
		public Group getGroup() { return cGroup; }
		
		//"goto"
		public Keyword getGotoKeyword_0() { return cGotoKeyword_0; }
		
		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall_1() { return cIDENTIFIERTerminalRuleCall_1; }
	}
	public class Package_clauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Package_clause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cPackageKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cIDENTIFIERTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		////Defer_stmt:
		////	"defer" Expression;
		////
		////Source_file:
		////	Package_clause SEMICOLON (Import_decl SEMICOLON)* (Top_level_decl SEMICOLON)*;
		////
		//Package_clause:
		//	"package" IDENTIFIER;
		@Override public ParserRule getRule() { return rule; }
		
		//"package" IDENTIFIER
		public Group getGroup() { return cGroup; }
		
		//"package"
		public Keyword getPackageKeyword_0() { return cPackageKeyword_0; }
		
		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall_1() { return cIDENTIFIERTerminalRuleCall_1; }
	}
	public class Import_declElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Import_decl");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cImportKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Alternatives cAlternatives_1 = (Alternatives)cGroup.eContents().get(1);
		private final RuleCall cImport_specParserRuleCall_1_0 = (RuleCall)cAlternatives_1.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cAlternatives_1.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Group cGroup_1_1_1 = (Group)cGroup_1_1.eContents().get(1);
		private final RuleCall cImport_specParserRuleCall_1_1_1_0 = (RuleCall)cGroup_1_1_1.eContents().get(0);
		private final RuleCall cSEMICOLONTerminalRuleCall_1_1_1_1 = (RuleCall)cGroup_1_1_1.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_1_1_2 = (Keyword)cGroup_1_1.eContents().get(2);
		
		//Import_decl:
		//	"import" (Import_spec | "(" (Import_spec SEMICOLON)* ")");
		@Override public ParserRule getRule() { return rule; }
		
		//"import" (Import_spec | "(" (Import_spec SEMICOLON)* ")")
		public Group getGroup() { return cGroup; }
		
		//"import"
		public Keyword getImportKeyword_0() { return cImportKeyword_0; }
		
		//Import_spec | "(" (Import_spec SEMICOLON)* ")"
		public Alternatives getAlternatives_1() { return cAlternatives_1; }
		
		//Import_spec
		public RuleCall getImport_specParserRuleCall_1_0() { return cImport_specParserRuleCall_1_0; }
		
		//"(" (Import_spec SEMICOLON)* ")"
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//"("
		public Keyword getLeftParenthesisKeyword_1_1_0() { return cLeftParenthesisKeyword_1_1_0; }
		
		//(Import_spec SEMICOLON)*
		public Group getGroup_1_1_1() { return cGroup_1_1_1; }
		
		//Import_spec
		public RuleCall getImport_specParserRuleCall_1_1_1_0() { return cImport_specParserRuleCall_1_1_1_0; }
		
		//SEMICOLON
		public RuleCall getSEMICOLONTerminalRuleCall_1_1_1_1() { return cSEMICOLONTerminalRuleCall_1_1_1_1; }
		
		//")"
		public Keyword getRightParenthesisKeyword_1_1_2() { return cRightParenthesisKeyword_1_1_2; }
	}
	public class Import_specElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Import_spec");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final RuleCall cIDENTIFIERTerminalRuleCall_0_1 = (RuleCall)cAlternatives_0.eContents().get(1);
		private final RuleCall cImport_pathParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//Import_spec:
		//	("." | IDENTIFIER)? Import_path;
		@Override public ParserRule getRule() { return rule; }
		
		//("." | IDENTIFIER)? Import_path
		public Group getGroup() { return cGroup; }
		
		//("." | IDENTIFIER)?
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//"."
		public Keyword getFullStopKeyword_0_0() { return cFullStopKeyword_0_0; }
		
		//IDENTIFIER
		public RuleCall getIDENTIFIERTerminalRuleCall_0_1() { return cIDENTIFIERTerminalRuleCall_0_1; }
		
		//Import_path
		public RuleCall getImport_pathParserRuleCall_1() { return cImport_pathParserRuleCall_1; }
	}
	public class Import_pathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.Import_path");
		private final RuleCall cString_litParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//Import_path:
		//	String_lit;
		@Override public ParserRule getRule() { return rule; }
		
		//String_lit
		public RuleCall getString_litParserRuleCall() { return cString_litParserRuleCall; }
	}
	
	
	private final ModelElements pModel;
	private final TerminalRule tSEMICOLON;
	private final TerminalRule tBINARY_OP;
	private final TerminalRule tREL_OP;
	private final TerminalRule tADD_OP;
	private final TerminalRule tMUL_OP;
	private final TerminalRule tUNARY_OP;
	private final TerminalRule tASSIGN_OP;
	private final TerminalRule tNEWLINE;
	private final TerminalRule tLETTER;
	private final TerminalRule tHEX_DIGIT;
	private final TerminalRule tKEYWORDS;
	private final TerminalRule tIDENTIFIER;
	private final OPERATORSElements pOPERATORS;
	private final TerminalRule tUNICODE_CHAR;
	private final TerminalRule tUNICODE_LETTER;
	private final TerminalRule tUNICODE_DIGIT;
	private final Int_litElements pInt_lit;
	private final TerminalRule tOCTAL_LIT;
	private final TerminalRule tHEX_LIT;
	private final Float_litElements pFloat_lit;
	private final ExponentElements pExponent;
	private final Imaginary_litElements pImaginary_lit;
	private final Rune_litElements pRune_lit;
	private final TerminalRule tUNICODE_VALUE;
	private final Byte_valueElements pByte_value;
	private final TerminalRule tOCTAL_BYTE_VALUE;
	private final TerminalRule tHEX_BYTE_VALUE;
	private final TerminalRule tLITTLE_U_VALUE;
	private final TerminalRule tBIG_U_VALUE;
	private final TerminalRule tESCAPED_CHAR;
	private final String_litElements pString_lit;
	private final TerminalRule tRAW_STRING_LIT;
	private final Interpreted_string_litElements pInterpreted_string_lit;
	private final LiteralsElements pLiterals;
	private final CommentElements pComment;
	private final TokenElements pToken;
	private final TypeElements pType;
	private final Type_nameElements pType_name;
	private final Type_litElements pType_lit;
	private final Array_typeElements pArray_type;
	private final Struct_typeElements pStruct_type;
	private final Field_declElements pField_decl;
	private final Embedded_fieldElements pEmbedded_field;
	private final Pointer_typeElements pPointer_type;
	private final ParametersElements pParameters;
	private final Parameter_listElements pParameter_list;
	private final Parameter_declElements pParameter_decl;
	private final Identifier_listElements pIdentifier_list;
	private final Qualified_identElements pQualified_ident;
	private final Empty_stmtElements pEmpty_stmt;
	private final Break_stmtElements pBreak_stmt;
	private final Continue_stmtElements pContinue_stmt;
	private final Goto_stmtElements pGoto_stmt;
	private final Package_clauseElements pPackage_clause;
	private final Import_declElements pImport_decl;
	private final Import_specElements pImport_spec;
	private final Import_pathElements pImport_path;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public GoGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pModel = new ModelElements();
		this.tSEMICOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.SEMICOLON");
		this.tBINARY_OP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.BINARY_OP");
		this.tREL_OP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.REL_OP");
		this.tADD_OP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.ADD_OP");
		this.tMUL_OP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.MUL_OP");
		this.tUNARY_OP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.UNARY_OP");
		this.tASSIGN_OP = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.ASSIGN_OP");
		this.tNEWLINE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.NEWLINE");
		this.tLETTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.LETTER");
		this.tHEX_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.HEX_DIGIT");
		this.tKEYWORDS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.KEYWORDS");
		this.tIDENTIFIER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.IDENTIFIER");
		this.pOPERATORS = new OPERATORSElements();
		this.tUNICODE_CHAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.UNICODE_CHAR");
		this.tUNICODE_LETTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.UNICODE_LETTER");
		this.tUNICODE_DIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.UNICODE_DIGIT");
		this.pInt_lit = new Int_litElements();
		this.tOCTAL_LIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.OCTAL_LIT");
		this.tHEX_LIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.HEX_LIT");
		this.pFloat_lit = new Float_litElements();
		this.pExponent = new ExponentElements();
		this.pImaginary_lit = new Imaginary_litElements();
		this.pRune_lit = new Rune_litElements();
		this.tUNICODE_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.UNICODE_VALUE");
		this.pByte_value = new Byte_valueElements();
		this.tOCTAL_BYTE_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.OCTAL_BYTE_VALUE");
		this.tHEX_BYTE_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.HEX_BYTE_VALUE");
		this.tLITTLE_U_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.LITTLE_U_VALUE");
		this.tBIG_U_VALUE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.BIG_U_VALUE");
		this.tESCAPED_CHAR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.ESCAPED_CHAR");
		this.pString_lit = new String_litElements();
		this.tRAW_STRING_LIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.Go.RAW_STRING_LIT");
		this.pInterpreted_string_lit = new Interpreted_string_litElements();
		this.pLiterals = new LiteralsElements();
		this.pComment = new CommentElements();
		this.pToken = new TokenElements();
		this.pType = new TypeElements();
		this.pType_name = new Type_nameElements();
		this.pType_lit = new Type_litElements();
		this.pArray_type = new Array_typeElements();
		this.pStruct_type = new Struct_typeElements();
		this.pField_decl = new Field_declElements();
		this.pEmbedded_field = new Embedded_fieldElements();
		this.pPointer_type = new Pointer_typeElements();
		this.pParameters = new ParametersElements();
		this.pParameter_list = new Parameter_listElements();
		this.pParameter_decl = new Parameter_declElements();
		this.pIdentifier_list = new Identifier_listElements();
		this.pQualified_ident = new Qualified_identElements();
		this.pEmpty_stmt = new Empty_stmtElements();
		this.pBreak_stmt = new Break_stmtElements();
		this.pContinue_stmt = new Continue_stmtElements();
		this.pGoto_stmt = new Goto_stmtElements();
		this.pPackage_clause = new Package_clauseElements();
		this.pImport_decl = new Import_declElements();
		this.pImport_spec = new Import_specElements();
		this.pImport_path = new Import_pathElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.Go".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//Model:
	//	greetings+="oi";
	public ModelElements getModelAccess() {
		return pModel;
	}
	
	public ParserRule getModelRule() {
		return getModelAccess().getRule();
	}
	
	//terminal SEMICOLON:
	//	';';
	public TerminalRule getSEMICOLONRule() {
		return tSEMICOLON;
	}
	
	//terminal BINARY_OP:
	//	"||" | "&&" | REL_OP | ADD_OP | MUL_OP;
	public TerminalRule getBINARY_OPRule() {
		return tBINARY_OP;
	}
	
	//terminal REL_OP:
	//	"==" | "!=" | "<" | "<=" | ">" | ">=";
	public TerminalRule getREL_OPRule() {
		return tREL_OP;
	}
	
	//terminal fragment ADD_OP:
	//	"+" | "-" | "|" | "^";
	public TerminalRule getADD_OPRule() {
		return tADD_OP;
	}
	
	//terminal fragment MUL_OP:
	//	"*" | "/" | "%" | "<<" | ">>" | "&" | "&^";
	public TerminalRule getMUL_OPRule() {
		return tMUL_OP;
	}
	
	//terminal UNARY_OP:
	//	"+" | "-" | "!" | "^" | "*" | "&" | "<-";
	public TerminalRule getUNARY_OPRule() {
		return tUNARY_OP;
	}
	
	//terminal ASSIGN_OP:
	//	(ADD_OP | MUL_OP)? "=";
	public TerminalRule getASSIGN_OPRule() {
		return tASSIGN_OP;
	}
	
	//terminal NEWLINE:
	//	'\\u000A';
	public TerminalRule getNEWLINERule() {
		return tNEWLINE;
	}
	
	//terminal LETTER:
	//	UNICODE_LETTER | '_';
	public TerminalRule getLETTERRule() {
		return tLETTER;
	}
	
	//terminal HEX_DIGIT:
	//	UNICODE_DIGIT | 'A'..'F' | 'a'..'f';
	public TerminalRule getHEX_DIGITRule() {
		return tHEX_DIGIT;
	}
	
	//terminal KEYWORDS:
	//	'break' | 'default' | 'func' | 'interface' | 'select' | 'case' | 'defer' | 'go' | 'map' | 'struct' | 'chan' | 'else' |
	//	'goto' | 'package' | 'switch' | 'const' | "fallthrough" | 'if' | 'range' | 'type' | 'continue' | 'for' | 'import' |
	//	'return' | 'var';
	public TerminalRule getKEYWORDSRule() {
		return tKEYWORDS;
	}
	
	//terminal IDENTIFIER:
	//	LETTER (LETTER | UNICODE_DIGIT)*;
	public TerminalRule getIDENTIFIERRule() {
		return tIDENTIFIER;
	}
	
	//fragment OPERATORS:
	//	BINARY_OP | '(' | ')' | '[' | ']' |
	//	'{' | '}' | '++' | '=' | ':=' | ',' | SEMICOLON |
	//	'--' | '...' | '.' | ':' | ASSIGN_OP;
	public OPERATORSElements getOPERATORSAccess() {
		return pOPERATORS;
	}
	
	public ParserRule getOPERATORSRule() {
		return getOPERATORSAccess().getRule();
	}
	
	//terminal fragment UNICODE_CHAR:
	//	'A'..'Z' | 'a'..'z';
	public TerminalRule getUNICODE_CHARRule() {
		return tUNICODE_CHAR;
	}
	
	//terminal UNICODE_LETTER:
	//	UNICODE_CHAR;
	public TerminalRule getUNICODE_LETTERRule() {
		return tUNICODE_LETTER;
	}
	
	//terminal fragment UNICODE_DIGIT:
	//	'0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9';
	public TerminalRule getUNICODE_DIGITRule() {
		return tUNICODE_DIGIT;
	}
	
	//////	'\\u0030'..'\\u0039' | '\\u0660'..'\\u0669' | '\\u06F0'..'\\u06F9' | '\\u07C0'..'\\u07C9' | '\\u0966'..'\\u096F' |
	//////	'\\u09E6'..'\\u09EF' | '\\u0A66'..'\\u0A6F' | '\\u0AE6'..'\\u0AEF' | '\\u0B66'..'\\u0B6F' | '\\u0BE6'..'\\u0BEF' |
	//////	'\\u0C66'..'\\u0C6F' | '\\u0CE6'..'\\u0CEF' | '\\u0D66'..'\\u0D6F' | '\\u0DE6'..'\\u0DEF' | '\\u0E50'..'\\u0E59' |
	//////	'\\u0ED0'..'\\u0ED9' | '\\u0F20'..'\\u0F29' | '\\u1040'..'\\u1049' | '\\u1090'..'\\u1099' | '\\u17E0'..'\\u17E9' |
	//////	'\\u1810'..'\\u1819' | '\\u1946'..'\\u194F' | '\\u19D0'..'\\u19D9' | '\\u1A80'..'\\u1A89' | '\\u1A90'..'\\u1A99' |
	//////	'\\u1B50'..'\\u1B59' | '\\u1BB0'..'\\u1BB9' | '\\u1C40'..'\\u1C49' | '\\u1C50'..'\\u1C59' | '\\uA620'..'\\uA629' |
	//////	'\\uA8D0'..'\\uA8D9' | '\\uA900'..'\\uA909' | '\\uA9D0'..'\\uA9D9' | '\\uA9F0'..'\\uA9F9' | '\\uAA50'..'\\uAA59' |
	//////	'\\uABF0'..'\\uABF9' | '\\uFF10'..'\\uFF19';
	////
	////
	//Int_lit:
	//	INT | OCTAL_LIT | HEX_LIT;
	public Int_litElements getInt_litAccess() {
		return pInt_lit;
	}
	
	public ParserRule getInt_litRule() {
		return getInt_litAccess().getRule();
	}
	
	//terminal OCTAL_LIT:
	//	'0' ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7')*;
	public TerminalRule getOCTAL_LITRule() {
		return tOCTAL_LIT;
	}
	
	//terminal HEX_LIT:
	//	'0' ('X' | 'x') HEX_DIGIT HEX_DIGIT*;
	public TerminalRule getHEX_LITRule() {
		return tHEX_LIT;
	}
	
	//Float_lit:
	//	INT ('.' INT? Exponent? | Exponent)
	//	'.' INT Exponent?;
	public Float_litElements getFloat_litAccess() {
		return pFloat_lit;
	}
	
	public ParserRule getFloat_litRule() {
		return getFloat_litAccess().getRule();
	}
	
	//Exponent:
	//	('E' | 'e') ('+' | '-')? INT;
	public ExponentElements getExponentAccess() {
		return pExponent;
	}
	
	public ParserRule getExponentRule() {
		return getExponentAccess().getRule();
	}
	
	//Imaginary_lit:
	//	(INT | Float_lit) 'i';
	public Imaginary_litElements getImaginary_litAccess() {
		return pImaginary_lit;
	}
	
	public ParserRule getImaginary_litRule() {
		return getImaginary_litAccess().getRule();
	}
	
	//Rune_lit:
	//	"'" (UNICODE_VALUE | Byte_value) "'";
	public Rune_litElements getRune_litAccess() {
		return pRune_lit;
	}
	
	public ParserRule getRune_litRule() {
		return getRune_litAccess().getRule();
	}
	
	//terminal UNICODE_VALUE:
	//	UNICODE_CHAR | LITTLE_U_VALUE | BIG_U_VALUE | ESCAPED_CHAR;
	public TerminalRule getUNICODE_VALUERule() {
		return tUNICODE_VALUE;
	}
	
	//Byte_value:
	//	OCTAL_BYTE_VALUE | HEX_BYTE_VALUE;
	public Byte_valueElements getByte_valueAccess() {
		return pByte_value;
	}
	
	public ParserRule getByte_valueRule() {
		return getByte_valueAccess().getRule();
	}
	
	//terminal OCTAL_BYTE_VALUE:
	//	"\\" ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7') ('0' | '1' | '2'
	//	| '3' | '4' | '5' | '6' | '7');
	public TerminalRule getOCTAL_BYTE_VALUERule() {
		return tOCTAL_BYTE_VALUE;
	}
	
	//terminal HEX_BYTE_VALUE:
	//	"\\" 'x' HEX_DIGIT HEX_DIGIT;
	public TerminalRule getHEX_BYTE_VALUERule() {
		return tHEX_BYTE_VALUE;
	}
	
	//terminal LITTLE_U_VALUE:
	//	"\\" 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;
	public TerminalRule getLITTLE_U_VALUERule() {
		return tLITTLE_U_VALUE;
	}
	
	//terminal BIG_U_VALUE:
	//	"\\" 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT;
	public TerminalRule getBIG_U_VALUERule() {
		return tBIG_U_VALUE;
	}
	
	//terminal ESCAPED_CHAR:
	//	"\\" ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\\' | "'" | '"');
	public TerminalRule getESCAPED_CHARRule() {
		return tESCAPED_CHAR;
	}
	
	//String_lit:
	//	RAW_STRING_LIT | Interpreted_string_lit;
	public String_litElements getString_litAccess() {
		return pString_lit;
	}
	
	public ParserRule getString_litRule() {
		return getString_litAccess().getRule();
	}
	
	//terminal RAW_STRING_LIT:
	//	'`' (UNICODE_CHAR | NEWLINE)* '`';
	public TerminalRule getRAW_STRING_LITRule() {
		return tRAW_STRING_LIT;
	}
	
	//Interpreted_string_lit:
	//	'"' (UNICODE_VALUE | Byte_value)* '"';
	public Interpreted_string_litElements getInterpreted_string_litAccess() {
		return pInterpreted_string_lit;
	}
	
	public ParserRule getInterpreted_string_litRule() {
		return getInterpreted_string_litAccess().getRule();
	}
	
	//Literals:
	//	Int_lit | Float_lit | Imaginary_lit | Rune_lit | String_lit;
	public LiteralsElements getLiteralsAccess() {
		return pLiterals;
	}
	
	public ParserRule getLiteralsRule() {
		return getLiteralsAccess().getRule();
	}
	
	//Comment:
	//	ML_COMMENT;
	public CommentElements getCommentAccess() {
		return pComment;
	}
	
	public ParserRule getCommentRule() {
		return getCommentAccess().getRule();
	}
	
	//Token:
	//	IDENTIFIER | KEYWORDS | OPERATORS | Literals;
	public TokenElements getTokenAccess() {
		return pToken;
	}
	
	public ParserRule getTokenRule() {
		return getTokenAccess().getRule();
	}
	
	//Type:
	//	Type_name;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	////| Type_lit | "(" Type ")";
	//Type_name:
	//	IDENTIFIER | Qualified_ident;
	public Type_nameElements getType_nameAccess() {
		return pType_name;
	}
	
	public ParserRule getType_nameRule() {
		return getType_nameAccess().getRule();
	}
	
	//Type_lit:
	//	Array_type | Struct_type | Pointer_type;
	public Type_litElements getType_litAccess() {
		return pType_lit;
	}
	
	public ParserRule getType_litRule() {
		return getType_litAccess().getRule();
	}
	
	////| Function_type |
	////Interface_type | Slice_type | Map_type | Channel_type;
	//Array_type:
	//	"[" Parameter_list "]" Type;
	public Array_typeElements getArray_typeAccess() {
		return pArray_type;
	}
	
	public ParserRule getArray_typeRule() {
		return getArray_typeAccess().getRule();
	}
	
	////Array_length:
	////	Parameter_list;
	////
	////Element_type:
	////	Type;
	//Struct_type:
	//	"struct" "{" (Field_decl SEMICOLON)* "}";
	public Struct_typeElements getStruct_typeAccess() {
		return pStruct_type;
	}
	
	public ParserRule getStruct_typeRule() {
		return getStruct_typeAccess().getRule();
	}
	
	//Field_decl:
	//	(Identifier_list Type | Embedded_field) String_lit?;
	public Field_declElements getField_declAccess() {
		return pField_decl;
	}
	
	public ParserRule getField_declRule() {
		return getField_declAccess().getRule();
	}
	
	//Embedded_field:
	//	"*"+ Type_name;
	public Embedded_fieldElements getEmbedded_fieldAccess() {
		return pEmbedded_field;
	}
	
	public ParserRule getEmbedded_fieldRule() {
		return getEmbedded_fieldAccess().getRule();
	}
	
	////Tag:
	////	String_lit;
	////
	//Pointer_type:
	//	"*" Type;
	public Pointer_typeElements getPointer_typeAccess() {
		return pPointer_type;
	}
	
	public ParserRule getPointer_typeRule() {
		return getPointer_typeAccess().getRule();
	}
	
	////Function_type:
	////	"func" Signature;
	////
	////Signature:
	////	Parameters (Parameters | Type)+;
	//Parameters:
	//	"(" (Parameter_list ","+)+ ")";
	public ParametersElements getParametersAccess() {
		return pParameters;
	}
	
	public ParserRule getParametersRule() {
		return getParametersAccess().getRule();
	}
	
	//Parameter_list:
	//	Parameter_decl ("," Parameter_decl)*;
	public Parameter_listElements getParameter_listAccess() {
		return pParameter_list;
	}
	
	public ParserRule getParameter_listRule() {
		return getParameter_listAccess().getRule();
	}
	
	//Parameter_decl: //{Identifier , Identifier} should be derivated through identifier_list
	//// and type before Identifier_list alone
	//	=> (Identifier_list)? "..."? Type;
	public Parameter_declElements getParameter_declAccess() {
		return pParameter_decl;
	}
	
	public ParserRule getParameter_declRule() {
		return getParameter_declAccess().getRule();
	}
	
	////Interface_type:
	////	=> "interface" "{" (Method_spec SEMICOLON)* "}";
	////
	////Method_spec:
	////	IDENTIFIER Signature | Interface_type_name;
	////
	////Interface_type_name:
	////	Type_name;
	////
	////Slice_type:
	////	"[" "]" Element_type;
	////
	////Map_type:
	////	"map" "[" Key_type "]" Element_type;
	////
	////Key_type:
	////	Type;
	////
	////Channel_type:
	////	(=> "chan" | "chan" "<-" | "<-" "chan") Element_type;
	////
	////Block:
	////	"{" Statement_list "}";
	////
	////Statement_list:
	////	(Statement SEMICOLON)*;
	////
	////Declaration:
	////	Const_decl | Type_decl | Var_decl;
	////
	////Top_level_decl:
	////	Declaration | Function_decl | Method_decl;
	////
	////Const_decl:
	////	"const" Const_spec | "(" (Const_spec SEMICOLON)* ")";
	////
	////Const_spec:
	////	Identifier_list ((Type)? "=" Expression_list)?;
	////
	//Identifier_list:
	//	IDENTIFIER ("," IDENTIFIER)*;
	public Identifier_listElements getIdentifier_listAccess() {
		return pIdentifier_list;
	}
	
	public ParserRule getIdentifier_listRule() {
		return getIdentifier_listAccess().getRule();
	}
	
	////Expression_list:
	////	Expression ("," Expression)*;
	////
	////Type_decl:
	////	"type" (Type_spec | "(" (Type_spec SEMICOLON)* ")");
	////
	////Type_spec:
	////	Alias_decl | Type_def;
	////
	////Alias_decl:
	////	IDENTIFIER "=" Type;
	////
	////Type_def:
	////	IDENTIFIER Type;
	////
	////Var_decl:
	////	"var" (Var_spec | "(" (Var_spec SEMICOLON)* ")");
	////
	////Var_spec:
	////	Identifier_list (Type ("=" Expression_list)? | "=" Expression_list);
	////
	////Short_var_decl:
	////	=> Identifier_list ":=" Expression_list;
	////
	////Function_decl:
	////	"func" IDENTIFIER Signature (Function_body)?;
	////
	////Function_body:
	////	Block;
	////
	////Method_decl:
	////	"func" Rreciever IDENTIFIER Signature (Function_body)?;
	////
	////Rreciever:
	////	Parameters;
	////
	////Operand:
	////	Literal | Operand_name | "(" Expression ")";
	////
	////Literal:
	////	Basic_lit | Composite_lit | Function_lit;
	////
	////Basic_lit:
	////	=> Int_lit | Float_lit | Imaginary_lit | Rune_lit | String_lit;
	////
	////Operand_name:
	////	=> IDENTIFIER | Qualified_ident;
	////
	//Qualified_ident:
	//	IDENTIFIER "." IDENTIFIER;
	public Qualified_identElements getQualified_identAccess() {
		return pQualified_ident;
	}
	
	public ParserRule getQualified_identRule() {
		return getQualified_identAccess().getRule();
	}
	
	////Composite_lit:
	////	Literal_type Literal_value;
	////
	////Literal_type:
	////	Struct_type | Array_type | "[" "..." "]" Element_type |
	////	Slice_type | Map_type | Type_name;
	////
	////Literal_value:
	////	"{" (Element_list (",")?)? "}";
	////
	////Element_list:
	////	Keyed_element ("," Keyed_element)*;
	////
	////Keyed_element:
	////	=> (Key ":")? Element;
	////
	////Key:
	////	IDENTIFIER | Expression | Literal_value;
	////
	////Element:
	////	Expression | Literal_value;
	////
	////Function_lit:
	////	"func" Signature Function_body;
	////
	////Primary_expr:
	////	Operand |
	////	Conversion |
	////	Method_expr |
	////	=> Primary_expr_selector |
	////	Primary_expr_index |
	////	Primary_expr_slice |
	////	Primary_expr_type_assertion |
	////	Primary_expr_arguments;
	////
	////Primary_expr_selector:
	////	Selector Primary_expr_selector | (=> Operand |
	////	Conversion |
	////	Method_expr);
	////
	////Primary_expr_index:
	////	Index Primary_expr_index | (=> Operand |
	////	Conversion |
	////	Method_expr);
	////
	////Primary_expr_slice:
	////	Slice Primary_expr_slice | (=> Operand |
	////	Conversion |
	////	Method_expr);
	////
	////Primary_expr_type_assertion:
	////	Type_assertion Primary_expr_type_assertion | (=> Operand |
	////	Conversion |
	////	Method_expr);
	////
	////Primary_expr_arguments:
	////	Arguments Primary_expr_arguments | (=> Operand |
	////	Conversion |
	////	Method_expr);
	////
	////Selector:
	////	"." IDENTIFIER;
	////
	////Index:
	////	"[" Expression "]";
	////
	////Slice:
	////	=> ("[" (Expression)? ":" (Expression)? "]") | ("[" (Expression)? ":" Expression ":" Expression "]");
	////
	////Type_assertion:
	////	"." "(" Type ")";
	////
	////Arguments:
	////	"(" (=> Expression_list | Type ("," Expression_list)? ("...")? (",")?)? ")";
	////
	////Method_expr:
	////	Reciever_type "." IDENTIFIER;
	////
	////Reciever_type:
	////	Type;
	////
	////Expression:
	////	Unary_expr Expression_line;
	////
	////Expression_line:
	////	BINARY_OP Expression Expression_line;
	////
	////Unary_expr:
	////	(Primary_expr | UNARY_OP)+;
	////
	////Conversion:
	////	Type "(" Expression (",")? ")";
	////
	////Statement:
	////	Declaration | Labeled_stmt | Simple_stmt | Go_stmt | Return_stmt |
	////	Break_stmt | Continue_stmt | Goto_stmt |
	////	"fallthrough" | Block | If_stmt | Switch_stmt |
	////	Select_stmt | For_stmt | Defer_stmt;
	////
	////Simple_stmt:
	////	Empty_stmt | Expression_stmt | Send_stmt | Inc_dec_stmt | Assignment | Short_var_decl;
	////
	//Empty_stmt:
	//	WS;
	public Empty_stmtElements getEmpty_stmtAccess() {
		return pEmpty_stmt;
	}
	
	public ParserRule getEmpty_stmtRule() {
		return getEmpty_stmtAccess().getRule();
	}
	
	////Labeled_stmt:
	////	=> IDENTIFIER ":" Statement;
	////
	////Expression_stmt:
	////	Expression;
	////
	////Send_stmt:
	////	=> Channel "<-" Expression;
	////
	////Channel:
	////	Expression;
	////
	////Inc_dec_stmt:
	////	=> Expression ("++" | "--");
	////
	////Assignment:
	////	=> Expression_list ASSIGN_OP Expression_list;
	////
	////If_stmt:
	////	"if" (Simple_stmt SEMICOLON)? => Expression Block ("else" (If_stmt | Block))?;
	////
	////Switch_stmt:
	////	=> Expr_switch_stmt | Type_switch_stmt;
	////
	////Expr_switch_stmt:
	////	"switch" (Simple_stmt SEMICOLON)? => (Expression)? "{" (Expr_case_clause)* "}";
	////
	////Expr_case_clause:
	////	Expr_switch_case ":" Statement_list;
	////
	////Expr_switch_case:
	////	"case" Expression_list | "default";
	////
	////Type_switch_stmt:
	////	"switch" (Simple_stmt SEMICOLON)? => Type_switch_guard "{" (Type_case_clause)* "}";
	////
	////Type_switch_guard:
	////	(IDENTIFIER ":=")? Primary_expr "." "(" "type" ")";
	////
	////Type_case_clause:
	////	Type_switch_case ":" Statement_list;
	////
	////Type_switch_case:
	////	"case" Type_list | "default";
	////
	////Type_list:
	////	Type ("," Type)*;
	////
	////For_stmt:
	////	"for" (=> Condition | For_clause | Range_clause)? Block;
	////
	////Condition:
	////	Expression;
	////
	////For_clause:
	////	(Init_stmt)? SEMICOLON (Condition)? SEMICOLON (Post_stmt)?;
	////
	////Init_stmt:
	////	Simple_stmt;
	////
	////Post_stmt:
	////	Simple_stmt;
	////
	////Range_clause:
	////	(Expression_list "=" | Identifier_list ":=")? "range" Expression;
	////
	////Go_stmt:
	////	"go" Expression;
	////
	////Select_stmt:
	////	"select" "{" (Comm_clause)* "}";
	////
	////Comm_clause:
	////	Comm_case ":" Statement_list;
	////
	////Comm_case:
	////	"case" (Send_stmt | Recv_stmt) | "default";
	////
	////Recv_stmt:
	////	(=> Expression_list "=" | Identifier_list ":=")? Recv_expr;
	////
	////Recv_expr:
	////	Expression;
	////
	////Return_stmt:
	////	"return" (Expression_list)?;
	////
	//Break_stmt:
	//	"break" IDENTIFIER?;
	public Break_stmtElements getBreak_stmtAccess() {
		return pBreak_stmt;
	}
	
	public ParserRule getBreak_stmtRule() {
		return getBreak_stmtAccess().getRule();
	}
	
	//Continue_stmt:
	//	"continue" IDENTIFIER?;
	public Continue_stmtElements getContinue_stmtAccess() {
		return pContinue_stmt;
	}
	
	public ParserRule getContinue_stmtRule() {
		return getContinue_stmtAccess().getRule();
	}
	
	//Goto_stmt:
	//	"goto" IDENTIFIER;
	public Goto_stmtElements getGoto_stmtAccess() {
		return pGoto_stmt;
	}
	
	public ParserRule getGoto_stmtRule() {
		return getGoto_stmtAccess().getRule();
	}
	
	////Defer_stmt:
	////	"defer" Expression;
	////
	////Source_file:
	////	Package_clause SEMICOLON (Import_decl SEMICOLON)* (Top_level_decl SEMICOLON)*;
	////
	//Package_clause:
	//	"package" IDENTIFIER;
	public Package_clauseElements getPackage_clauseAccess() {
		return pPackage_clause;
	}
	
	public ParserRule getPackage_clauseRule() {
		return getPackage_clauseAccess().getRule();
	}
	
	//Import_decl:
	//	"import" (Import_spec | "(" (Import_spec SEMICOLON)* ")");
	public Import_declElements getImport_declAccess() {
		return pImport_decl;
	}
	
	public ParserRule getImport_declRule() {
		return getImport_declAccess().getRule();
	}
	
	//Import_spec:
	//	("." | IDENTIFIER)? Import_path;
	public Import_specElements getImport_specAccess() {
		return pImport_spec;
	}
	
	public ParserRule getImport_specRule() {
		return getImport_specAccess().getRule();
	}
	
	//Import_path:
	//	String_lit;
	public Import_pathElements getImport_pathAccess() {
		return pImport_path;
	}
	
	public ParserRule getImport_pathRule() {
		return getImport_pathAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
