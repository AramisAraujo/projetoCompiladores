/*
 * generated by Xtext 2.14.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.go.GoPackage;
import org.xtext.go.Model;
import org.xtext.go.anonymousField;
import org.xtext.go.arguments;
import org.xtext.go.arrayLength;
import org.xtext.go.arrayType;
import org.xtext.go.assignment;
import org.xtext.go.block;
import org.xtext.go.breakStmt;
import org.xtext.go.channelType;
import org.xtext.go.commCase;
import org.xtext.go.commClause;
import org.xtext.go.compositeLit;
import org.xtext.go.constDecl;
import org.xtext.go.constSpec;
import org.xtext.go.continueStmt;
import org.xtext.go.conversion;
import org.xtext.go.declaration;
import org.xtext.go.deferStmt;
import org.xtext.go.element;
import org.xtext.go.elementList;
import org.xtext.go.elementType;
import org.xtext.go.emptyStmt;
import org.xtext.go.exprCaseClause;
import org.xtext.go.exprSwitchCase;
import org.xtext.go.exprSwitchStmt;
import org.xtext.go.expression;
import org.xtext.go.expressionList;
import org.xtext.go.expressionMatched;
import org.xtext.go.expressionStmt;
import org.xtext.go.fallthroughStmt;
import org.xtext.go.fieldDecl;
import org.xtext.go.forClause;
import org.xtext.go.forStmt;
import org.xtext.go.function;
import org.xtext.go.functionDecl;
import org.xtext.go.functionLit;
import org.xtext.go.functionType;
import org.xtext.go.goStmt;
import org.xtext.go.gotoStmt;
import org.xtext.go.identifierList;
import org.xtext.go.ifStmt;
import org.xtext.go.importDecl;
import org.xtext.go.importSpec;
import org.xtext.go.incDecStmt;
import org.xtext.go.index;
import org.xtext.go.interfaceType;
import org.xtext.go.key;
import org.xtext.go.keyedElement;
import org.xtext.go.labeledStmt;
import org.xtext.go.literal;
import org.xtext.go.literalType;
import org.xtext.go.literalValue;
import org.xtext.go.mapType;
import org.xtext.go.methodDecl;
import org.xtext.go.methodExpr;
import org.xtext.go.methodSpec;
import org.xtext.go.operand;
import org.xtext.go.operandName;
import org.xtext.go.packageClause;
import org.xtext.go.parameterDecl;
import org.xtext.go.parameterList;
import org.xtext.go.parameters;
import org.xtext.go.pointerType;
import org.xtext.go.primaryExpr;
import org.xtext.go.primaryExprArguments;
import org.xtext.go.primaryExprIndex;
import org.xtext.go.primaryExprSelector;
import org.xtext.go.primaryExprSlice;
import org.xtext.go.primaryExprStuff;
import org.xtext.go.primaryExprTypeAssertion;
import org.xtext.go.qualifiedIdent;
import org.xtext.go.rangeClause;
import org.xtext.go.receiver;
import org.xtext.go.receiverType;
import org.xtext.go.recvStmt;
import org.xtext.go.result;
import org.xtext.go.returnStmt;
import org.xtext.go.selectStmt;
import org.xtext.go.selector;
import org.xtext.go.sendStmt;
import org.xtext.go.shortVarDecl;
import org.xtext.go.signature;
import org.xtext.go.simpleStmt;
import org.xtext.go.slice;
import org.xtext.go.sliceType;
import org.xtext.go.sourceFile;
import org.xtext.go.statement;
import org.xtext.go.statementList;
import org.xtext.go.structType;
import org.xtext.go.switchStmt;
import org.xtext.go.topLevelDecl;
import org.xtext.go.type;
import org.xtext.go.typeAssertion;
import org.xtext.go.typeCaseClause;
import org.xtext.go.typeDecl;
import org.xtext.go.typeList;
import org.xtext.go.typeLit;
import org.xtext.go.typeName;
import org.xtext.go.typeSpec;
import org.xtext.go.typeSwitchCase;
import org.xtext.go.typeSwitchGuard;
import org.xtext.go.typeSwitchStmt;
import org.xtext.go.unaryExpr;
import org.xtext.go.varDecl;
import org.xtext.go.varSpec;
import org.xtext.services.GoGrammarAccess;

@SuppressWarnings("all")
public class GoSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GoGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GoPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GoPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case GoPackage.ANONYMOUS_FIELD:
				sequence_anonymousField(context, (anonymousField) semanticObject); 
				return; 
			case GoPackage.ARGUMENTS:
				sequence_arguments(context, (arguments) semanticObject); 
				return; 
			case GoPackage.ARRAY_LENGTH:
				sequence_arrayLength(context, (arrayLength) semanticObject); 
				return; 
			case GoPackage.ARRAY_TYPE:
				sequence_arrayType(context, (arrayType) semanticObject); 
				return; 
			case GoPackage.ASSIGNMENT:
				sequence_assignment(context, (assignment) semanticObject); 
				return; 
			case GoPackage.BLOCK:
				sequence_block(context, (block) semanticObject); 
				return; 
			case GoPackage.BREAK_STMT:
				sequence_breakStmt(context, (breakStmt) semanticObject); 
				return; 
			case GoPackage.CHANNEL_TYPE:
				sequence_channelType(context, (channelType) semanticObject); 
				return; 
			case GoPackage.COMM_CASE:
				sequence_commCase(context, (commCase) semanticObject); 
				return; 
			case GoPackage.COMM_CLAUSE:
				sequence_commClause(context, (commClause) semanticObject); 
				return; 
			case GoPackage.COMPOSITE_LIT:
				sequence_compositeLit(context, (compositeLit) semanticObject); 
				return; 
			case GoPackage.CONST_DECL:
				sequence_constDecl(context, (constDecl) semanticObject); 
				return; 
			case GoPackage.CONST_SPEC:
				sequence_constSpec(context, (constSpec) semanticObject); 
				return; 
			case GoPackage.CONTINUE_STMT:
				sequence_continueStmt(context, (continueStmt) semanticObject); 
				return; 
			case GoPackage.CONVERSION:
				sequence_conversion(context, (conversion) semanticObject); 
				return; 
			case GoPackage.DECLARATION:
				sequence_declaration(context, (declaration) semanticObject); 
				return; 
			case GoPackage.DEFER_STMT:
				sequence_deferStmt(context, (deferStmt) semanticObject); 
				return; 
			case GoPackage.ELEMENT:
				sequence_element(context, (element) semanticObject); 
				return; 
			case GoPackage.ELEMENT_LIST:
				sequence_elementList(context, (elementList) semanticObject); 
				return; 
			case GoPackage.ELEMENT_TYPE:
				sequence_elementType(context, (elementType) semanticObject); 
				return; 
			case GoPackage.EMPTY_STMT:
				sequence_emptyStmt(context, (emptyStmt) semanticObject); 
				return; 
			case GoPackage.EXPR_CASE_CLAUSE:
				sequence_exprCaseClause(context, (exprCaseClause) semanticObject); 
				return; 
			case GoPackage.EXPR_SWITCH_CASE:
				sequence_exprSwitchCase(context, (exprSwitchCase) semanticObject); 
				return; 
			case GoPackage.EXPR_SWITCH_STMT:
				sequence_exprSwitchStmt(context, (exprSwitchStmt) semanticObject); 
				return; 
			case GoPackage.EXPRESSION:
				sequence_expression(context, (expression) semanticObject); 
				return; 
			case GoPackage.EXPRESSION_LIST:
				sequence_expressionList(context, (expressionList) semanticObject); 
				return; 
			case GoPackage.EXPRESSION_MATCHED:
				sequence_expressionMatched(context, (expressionMatched) semanticObject); 
				return; 
			case GoPackage.EXPRESSION_STMT:
				sequence_expressionStmt(context, (expressionStmt) semanticObject); 
				return; 
			case GoPackage.FALLTHROUGH_STMT:
				sequence_fallthroughStmt(context, (fallthroughStmt) semanticObject); 
				return; 
			case GoPackage.FIELD_DECL:
				sequence_fieldDecl(context, (fieldDecl) semanticObject); 
				return; 
			case GoPackage.FOR_CLAUSE:
				sequence_forClause(context, (forClause) semanticObject); 
				return; 
			case GoPackage.FOR_STMT:
				sequence_forStmt(context, (forStmt) semanticObject); 
				return; 
			case GoPackage.FUNCTION:
				sequence_function(context, (function) semanticObject); 
				return; 
			case GoPackage.FUNCTION_DECL:
				sequence_functionDecl(context, (functionDecl) semanticObject); 
				return; 
			case GoPackage.FUNCTION_LIT:
				sequence_functionLit(context, (functionLit) semanticObject); 
				return; 
			case GoPackage.FUNCTION_TYPE:
				sequence_functionType(context, (functionType) semanticObject); 
				return; 
			case GoPackage.GO_STMT:
				sequence_goStmt(context, (goStmt) semanticObject); 
				return; 
			case GoPackage.GOTO_STMT:
				sequence_gotoStmt(context, (gotoStmt) semanticObject); 
				return; 
			case GoPackage.IDENTIFIER_LIST:
				sequence_identifierList(context, (identifierList) semanticObject); 
				return; 
			case GoPackage.IF_STMT:
				sequence_ifStmt(context, (ifStmt) semanticObject); 
				return; 
			case GoPackage.IMPORT_DECL:
				sequence_importDecl(context, (importDecl) semanticObject); 
				return; 
			case GoPackage.IMPORT_SPEC:
				sequence_importSpec(context, (importSpec) semanticObject); 
				return; 
			case GoPackage.INC_DEC_STMT:
				sequence_incDecStmt(context, (incDecStmt) semanticObject); 
				return; 
			case GoPackage.INDEX:
				sequence_index(context, (index) semanticObject); 
				return; 
			case GoPackage.INTERFACE_TYPE:
				sequence_interfaceType(context, (interfaceType) semanticObject); 
				return; 
			case GoPackage.KEY:
				sequence_key(context, (key) semanticObject); 
				return; 
			case GoPackage.KEYED_ELEMENT:
				sequence_keyedElement(context, (keyedElement) semanticObject); 
				return; 
			case GoPackage.LABELED_STMT:
				sequence_labeledStmt(context, (labeledStmt) semanticObject); 
				return; 
			case GoPackage.LITERAL:
				sequence_literal(context, (literal) semanticObject); 
				return; 
			case GoPackage.LITERAL_TYPE:
				sequence_literalType(context, (literalType) semanticObject); 
				return; 
			case GoPackage.LITERAL_VALUE:
				sequence_literalValue(context, (literalValue) semanticObject); 
				return; 
			case GoPackage.MAP_TYPE:
				sequence_mapType(context, (mapType) semanticObject); 
				return; 
			case GoPackage.METHOD_DECL:
				sequence_methodDecl(context, (methodDecl) semanticObject); 
				return; 
			case GoPackage.METHOD_EXPR:
				sequence_methodExpr(context, (methodExpr) semanticObject); 
				return; 
			case GoPackage.METHOD_SPEC:
				sequence_methodSpec(context, (methodSpec) semanticObject); 
				return; 
			case GoPackage.OPERAND:
				sequence_operand(context, (operand) semanticObject); 
				return; 
			case GoPackage.OPERAND_NAME:
				sequence_operandName(context, (operandName) semanticObject); 
				return; 
			case GoPackage.PACKAGE_CLAUSE:
				sequence_packageClause(context, (packageClause) semanticObject); 
				return; 
			case GoPackage.PARAMETER_DECL:
				sequence_parameterDecl(context, (parameterDecl) semanticObject); 
				return; 
			case GoPackage.PARAMETER_LIST:
				sequence_parameterList(context, (parameterList) semanticObject); 
				return; 
			case GoPackage.PARAMETERS:
				sequence_parameters(context, (parameters) semanticObject); 
				return; 
			case GoPackage.POINTER_TYPE:
				sequence_pointerType(context, (pointerType) semanticObject); 
				return; 
			case GoPackage.PRIMARY_EXPR:
				sequence_primaryExpr(context, (primaryExpr) semanticObject); 
				return; 
			case GoPackage.PRIMARY_EXPR_ARGUMENTS:
				sequence_primaryExprArguments(context, (primaryExprArguments) semanticObject); 
				return; 
			case GoPackage.PRIMARY_EXPR_INDEX:
				sequence_primaryExprIndex(context, (primaryExprIndex) semanticObject); 
				return; 
			case GoPackage.PRIMARY_EXPR_SELECTOR:
				sequence_primaryExprSelector(context, (primaryExprSelector) semanticObject); 
				return; 
			case GoPackage.PRIMARY_EXPR_SLICE:
				sequence_primaryExprSlice(context, (primaryExprSlice) semanticObject); 
				return; 
			case GoPackage.PRIMARY_EXPR_STUFF:
				sequence_primaryExprStuff(context, (primaryExprStuff) semanticObject); 
				return; 
			case GoPackage.PRIMARY_EXPR_TYPE_ASSERTION:
				sequence_primaryExprTypeAssertion(context, (primaryExprTypeAssertion) semanticObject); 
				return; 
			case GoPackage.QUALIFIED_IDENT:
				sequence_qualifiedIdent(context, (qualifiedIdent) semanticObject); 
				return; 
			case GoPackage.RANGE_CLAUSE:
				sequence_rangeClause(context, (rangeClause) semanticObject); 
				return; 
			case GoPackage.RECEIVER:
				sequence_receiver(context, (receiver) semanticObject); 
				return; 
			case GoPackage.RECEIVER_TYPE:
				sequence_receiverType(context, (receiverType) semanticObject); 
				return; 
			case GoPackage.RECV_STMT:
				sequence_recvStmt(context, (recvStmt) semanticObject); 
				return; 
			case GoPackage.RESULT:
				sequence_result(context, (result) semanticObject); 
				return; 
			case GoPackage.RETURN_STMT:
				sequence_returnStmt(context, (returnStmt) semanticObject); 
				return; 
			case GoPackage.SELECT_STMT:
				sequence_selectStmt(context, (selectStmt) semanticObject); 
				return; 
			case GoPackage.SELECTOR:
				sequence_selector(context, (selector) semanticObject); 
				return; 
			case GoPackage.SEND_STMT:
				sequence_sendStmt(context, (sendStmt) semanticObject); 
				return; 
			case GoPackage.SHORT_VAR_DECL:
				sequence_shortVarDecl(context, (shortVarDecl) semanticObject); 
				return; 
			case GoPackage.SIGNATURE:
				sequence_signature(context, (signature) semanticObject); 
				return; 
			case GoPackage.SIMPLE_STMT:
				sequence_simpleStmt(context, (simpleStmt) semanticObject); 
				return; 
			case GoPackage.SLICE:
				sequence_slice(context, (slice) semanticObject); 
				return; 
			case GoPackage.SLICE_TYPE:
				sequence_sliceType(context, (sliceType) semanticObject); 
				return; 
			case GoPackage.SOURCE_FILE:
				sequence_sourceFile(context, (sourceFile) semanticObject); 
				return; 
			case GoPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case GoPackage.STATEMENT_LIST:
				sequence_statementList(context, (statementList) semanticObject); 
				return; 
			case GoPackage.STRUCT_TYPE:
				sequence_structType(context, (structType) semanticObject); 
				return; 
			case GoPackage.SWITCH_STMT:
				sequence_switchStmt(context, (switchStmt) semanticObject); 
				return; 
			case GoPackage.TOP_LEVEL_DECL:
				sequence_topLevelDecl(context, (topLevelDecl) semanticObject); 
				return; 
			case GoPackage.TYPE:
				sequence_type(context, (type) semanticObject); 
				return; 
			case GoPackage.TYPE_ASSERTION:
				sequence_typeAssertion(context, (typeAssertion) semanticObject); 
				return; 
			case GoPackage.TYPE_CASE_CLAUSE:
				sequence_typeCaseClause(context, (typeCaseClause) semanticObject); 
				return; 
			case GoPackage.TYPE_DECL:
				sequence_typeDecl(context, (typeDecl) semanticObject); 
				return; 
			case GoPackage.TYPE_LIST:
				sequence_typeList(context, (typeList) semanticObject); 
				return; 
			case GoPackage.TYPE_LIT:
				sequence_typeLit(context, (typeLit) semanticObject); 
				return; 
			case GoPackage.TYPE_NAME:
				sequence_typeName(context, (typeName) semanticObject); 
				return; 
			case GoPackage.TYPE_SPEC:
				sequence_typeSpec(context, (typeSpec) semanticObject); 
				return; 
			case GoPackage.TYPE_SWITCH_CASE:
				sequence_typeSwitchCase(context, (typeSwitchCase) semanticObject); 
				return; 
			case GoPackage.TYPE_SWITCH_GUARD:
				sequence_typeSwitchGuard(context, (typeSwitchGuard) semanticObject); 
				return; 
			case GoPackage.TYPE_SWITCH_STMT:
				sequence_typeSwitchStmt(context, (typeSwitchStmt) semanticObject); 
				return; 
			case GoPackage.UNARY_EXPR:
				sequence_unaryExpr(context, (unaryExpr) semanticObject); 
				return; 
			case GoPackage.VAR_DECL:
				sequence_varDecl(context, (varDecl) semanticObject); 
				return; 
			case GoPackage.VAR_SPEC:
				sequence_varSpec(context, (varSpec) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     greetings+=sourceFile
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     anonymousField returns anonymousField
	 *
	 * Constraint:
	 *     typeName=typeName
	 */
	protected void sequence_anonymousField(ISerializationContext context, anonymousField semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ANONYMOUS_FIELD__TYPE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ANONYMOUS_FIELD__TYPE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAnonymousFieldAccess().getTypeNameTypeNameParserRuleCall_1_0(), semanticObject.getTypeName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     arguments returns arguments
	 *
	 * Constraint:
	 *     (expressionList=expressionList | (type=type expressionList=expressionList?))
	 */
	protected void sequence_arguments(ISerializationContext context, arguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     arrayLength returns arrayLength
	 *
	 * Constraint:
	 *     expr=expression
	 */
	protected void sequence_arrayLength(ISerializationContext context, arrayLength semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ARRAY_LENGTH__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ARRAY_LENGTH__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayLengthAccess().getExprExpressionParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     arrayType returns arrayType
	 *
	 * Constraint:
	 *     (arrayLength=arrayLength elemType=elementType)
	 */
	protected void sequence_arrayType(ISerializationContext context, arrayType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ARRAY_TYPE__ARRAY_LENGTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ARRAY_TYPE__ARRAY_LENGTH));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ARRAY_TYPE__ELEM_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ARRAY_TYPE__ELEM_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayTypeAccess().getArrayLengthArrayLengthParserRuleCall_1_0(), semanticObject.getArrayLength());
		feeder.accept(grammarAccess.getArrayTypeAccess().getElemTypeElementTypeParserRuleCall_3_0(), semanticObject.getElemType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     assignment returns assignment
	 *
	 * Constraint:
	 *     (exprList1=expressionList operation=assign_op exprList2=expressionList)
	 */
	protected void sequence_assignment(ISerializationContext context, assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ASSIGNMENT__EXPR_LIST1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ASSIGNMENT__EXPR_LIST1));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ASSIGNMENT__OPERATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ASSIGNMENT__OPERATION));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ASSIGNMENT__EXPR_LIST2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ASSIGNMENT__EXPR_LIST2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getExprList1ExpressionListParserRuleCall_0_0(), semanticObject.getExprList1());
		feeder.accept(grammarAccess.getAssignmentAccess().getOperationAssign_opParserRuleCall_1_0(), semanticObject.getOperation());
		feeder.accept(grammarAccess.getAssignmentAccess().getExprList2ExpressionListParserRuleCall_2_0(), semanticObject.getExprList2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     block returns block
	 *
	 * Constraint:
	 *     statements=statementList
	 */
	protected void sequence_block(ISerializationContext context, block semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.BLOCK__STATEMENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.BLOCK__STATEMENTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBlockAccess().getStatementsStatementListParserRuleCall_1_0(), semanticObject.getStatements());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     breakStmt returns breakStmt
	 *
	 * Constraint:
	 *     label=IDENTIFIER
	 */
	protected void sequence_breakStmt(ISerializationContext context, breakStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.BREAK_STMT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.BREAK_STMT__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBreakStmtAccess().getLabelIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     channelType returns channelType
	 *
	 * Constraint:
	 *     elemType=elementType
	 */
	protected void sequence_channelType(ISerializationContext context, channelType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CHANNEL_TYPE__ELEM_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CHANNEL_TYPE__ELEM_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getChannelTypeAccess().getElemTypeElementTypeParserRuleCall_1_0(), semanticObject.getElemType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     commCase returns commCase
	 *
	 * Constraint:
	 *     (statement=sendStmt | statement=recvStmt)
	 */
	protected void sequence_commCase(ISerializationContext context, commCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     commClause returns commClause
	 *
	 * Constraint:
	 *     (case=commCase stmtList=statementList)
	 */
	protected void sequence_commClause(ISerializationContext context, commClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.COMM_CLAUSE__CASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.COMM_CLAUSE__CASE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.COMM_CLAUSE__STMT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.COMM_CLAUSE__STMT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommClauseAccess().getCaseCommCaseParserRuleCall_0_0(), semanticObject.getCase());
		feeder.accept(grammarAccess.getCommClauseAccess().getStmtListStatementListParserRuleCall_2_0(), semanticObject.getStmtList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     compositeLit returns compositeLit
	 *
	 * Constraint:
	 *     (literalType=literalType literalValue=literalValue)
	 */
	protected void sequence_compositeLit(ISerializationContext context, compositeLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.COMPOSITE_LIT__LITERAL_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.COMPOSITE_LIT__LITERAL_TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.COMPOSITE_LIT__LITERAL_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.COMPOSITE_LIT__LITERAL_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompositeLitAccess().getLiteralTypeLiteralTypeParserRuleCall_0_0(), semanticObject.getLiteralType());
		feeder.accept(grammarAccess.getCompositeLitAccess().getLiteralValueLiteralValueParserRuleCall_1_0(), semanticObject.getLiteralValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constDecl returns constDecl
	 *
	 * Constraint:
	 *     (spec+=constSpec | spec+=constSpec+)
	 */
	protected void sequence_constDecl(ISerializationContext context, constDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constSpec returns constSpec
	 *
	 * Constraint:
	 *     (identifiers=identifierList (type=type? expression=expressionList)?)
	 */
	protected void sequence_constSpec(ISerializationContext context, constSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     continueStmt returns continueStmt
	 *
	 * Constraint:
	 *     label=IDENTIFIER
	 */
	protected void sequence_continueStmt(ISerializationContext context, continueStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONTINUE_STMT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONTINUE_STMT__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContinueStmtAccess().getLabelIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     conversion returns conversion
	 *
	 * Constraint:
	 *     (type=type expression=expression)
	 */
	protected void sequence_conversion(ISerializationContext context, conversion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.CONVERSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConversionAccess().getTypeTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConversionAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     declaration returns declaration
	 *
	 * Constraint:
	 *     (decl=constDecl | decl=typeDecl | decl=varDecl)
	 */
	protected void sequence_declaration(ISerializationContext context, declaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     deferStmt returns deferStmt
	 *
	 * Constraint:
	 *     expr=expression
	 */
	protected void sequence_deferStmt(ISerializationContext context, deferStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.DEFER_STMT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.DEFER_STMT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeferStmtAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     elementList returns elementList
	 *
	 * Constraint:
	 *     (keyedElements+=keyedElement keyedElements+=keyedElement*)
	 */
	protected void sequence_elementList(ISerializationContext context, elementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     elementType returns elementType
	 *
	 * Constraint:
	 *     type=type
	 */
	protected void sequence_elementType(ISerializationContext context, elementType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.ELEMENT_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.ELEMENT_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementTypeAccess().getTypeTypeParserRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     element returns element
	 *
	 * Constraint:
	 *     (content=expression | content=literalValue)
	 */
	protected void sequence_element(ISerializationContext context, element semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     emptyStmt returns emptyStmt
	 *
	 * Constraint:
	 *     content=WS
	 */
	protected void sequence_emptyStmt(ISerializationContext context, emptyStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.EMPTY_STMT__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.EMPTY_STMT__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmptyStmtAccess().getContentWSTerminalRuleCall_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     exprCaseClause returns exprCaseClause
	 *
	 * Constraint:
	 *     (exprSwitchCase=exprSwitchCase stmtList=statementList)
	 */
	protected void sequence_exprCaseClause(ISerializationContext context, exprCaseClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.EXPR_CASE_CLAUSE__EXPR_SWITCH_CASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.EXPR_CASE_CLAUSE__EXPR_SWITCH_CASE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.EXPR_CASE_CLAUSE__STMT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.EXPR_CASE_CLAUSE__STMT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExprCaseClauseAccess().getExprSwitchCaseExprSwitchCaseParserRuleCall_0_0(), semanticObject.getExprSwitchCase());
		feeder.accept(grammarAccess.getExprCaseClauseAccess().getStmtListStatementListParserRuleCall_2_0(), semanticObject.getStmtList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     exprSwitchCase returns exprSwitchCase
	 *
	 * Constraint:
	 *     exprList=expressionList
	 */
	protected void sequence_exprSwitchCase(ISerializationContext context, exprSwitchCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.EXPR_SWITCH_CASE__EXPR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.EXPR_SWITCH_CASE__EXPR_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExprSwitchCaseAccess().getExprListExpressionListParserRuleCall_0_1_0(), semanticObject.getExprList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     exprSwitchStmt returns exprSwitchStmt
	 *
	 * Constraint:
	 *     (simpleStmt=simpleStmt? expr=expression? exprCaseClauses+=exprCaseClause*)
	 */
	protected void sequence_exprSwitchStmt(ISerializationContext context, exprSwitchStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expressionList returns expressionList
	 *
	 * Constraint:
	 *     (expr+=expression expr+=expression*)
	 */
	protected void sequence_expressionList(ISerializationContext context, expressionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expressionMatched returns expressionMatched
	 *
	 * Constraint:
	 *     expression=expression
	 */
	protected void sequence_expressionMatched(ISerializationContext context, expressionMatched semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.EXPRESSION_MATCHED__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.EXPRESSION_MATCHED__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionMatchedAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expressionStmt returns expressionStmt
	 *
	 * Constraint:
	 *     expr=expression
	 */
	protected void sequence_expressionStmt(ISerializationContext context, expressionStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.EXPRESSION_STMT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.EXPRESSION_STMT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStmtAccess().getExprExpressionParserRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expression returns expression
	 *
	 * Constraint:
	 *     (unaryExpr=unaryExpr expressionMatched=expressionMatched)
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.EXPRESSION__UNARY_EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.EXPRESSION__UNARY_EXPR));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.EXPRESSION__EXPRESSION_MATCHED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.EXPRESSION__EXPRESSION_MATCHED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getUnaryExprUnaryExprParserRuleCall_0_0(), semanticObject.getUnaryExpr());
		feeder.accept(grammarAccess.getExpressionAccess().getExpressionMatchedExpressionMatchedParserRuleCall_1_0(), semanticObject.getExpressionMatched());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     fallthroughStmt returns fallthroughStmt
	 *
	 * Constraint:
	 *     content='fallthrough'
	 */
	protected void sequence_fallthroughStmt(ISerializationContext context, fallthroughStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.FALLTHROUGH_STMT__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.FALLTHROUGH_STMT__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFallthroughStmtAccess().getContentFallthroughKeyword_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     fieldDecl returns fieldDecl
	 *
	 * Constraint:
	 *     ((identifierList=identifierList type=type) | anonymousField=anonymousField)
	 */
	protected void sequence_fieldDecl(ISerializationContext context, fieldDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     forClause returns forClause
	 *
	 * Constraint:
	 *     (statement1=simpleStmt? expr=expression? statement2=simpleStmt?)
	 */
	protected void sequence_forClause(ISerializationContext context, forClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     forStmt returns forStmt
	 *
	 * Constraint:
	 *     ((expr=expression | clause=forClause | clause=rangeClause)? codeBlock=block)
	 */
	protected void sequence_forStmt(ISerializationContext context, forStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     functionDecl returns functionDecl
	 *
	 * Constraint:
	 *     (name=IDENTIFIER (func=function | sig=signature))
	 */
	protected void sequence_functionDecl(ISerializationContext context, functionDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     functionLit returns functionLit
	 *
	 * Constraint:
	 *     function=function
	 */
	protected void sequence_functionLit(ISerializationContext context, functionLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.FUNCTION_LIT__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.FUNCTION_LIT__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionLitAccess().getFunctionFunctionParserRuleCall_1_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     functionType returns functionType
	 *
	 * Constraint:
	 *     sig=signature
	 */
	protected void sequence_functionType(ISerializationContext context, functionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.FUNCTION_TYPE__SIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.FUNCTION_TYPE__SIG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionTypeAccess().getSigSignatureParserRuleCall_1_0(), semanticObject.getSig());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     function returns function
	 *
	 * Constraint:
	 *     (sig=signature codeBlock=block)
	 */
	protected void sequence_function(ISerializationContext context, function semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.FUNCTION__SIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.FUNCTION__SIG));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.FUNCTION__CODE_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.FUNCTION__CODE_BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionAccess().getSigSignatureParserRuleCall_0_0(), semanticObject.getSig());
		feeder.accept(grammarAccess.getFunctionAccess().getCodeBlockBlockParserRuleCall_1_0(), semanticObject.getCodeBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     goStmt returns goStmt
	 *
	 * Constraint:
	 *     expr=expression
	 */
	protected void sequence_goStmt(ISerializationContext context, goStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.GO_STMT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.GO_STMT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGoStmtAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     gotoStmt returns gotoStmt
	 *
	 * Constraint:
	 *     label=IDENTIFIER
	 */
	protected void sequence_gotoStmt(ISerializationContext context, gotoStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.GOTO_STMT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.GOTO_STMT__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGotoStmtAccess().getLabelIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     identifierList returns identifierList
	 *
	 * Constraint:
	 *     (ids+=IDENTIFIER ids+=IDENTIFIER*)
	 */
	protected void sequence_identifierList(ISerializationContext context, identifierList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ifStmt returns ifStmt
	 *
	 * Constraint:
	 *     (simplStatement=simpleStmt? expr=expression codeBlock=block (ifStatement=ifStmt | codeBlockIf=block)?)
	 */
	protected void sequence_ifStmt(ISerializationContext context, ifStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     importDecl returns importDecl
	 *
	 * Constraint:
	 *     (specs+=importSpec | specs+=importSpec+)
	 */
	protected void sequence_importDecl(ISerializationContext context, importDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     importSpec returns importSpec
	 *
	 * Constraint:
	 *     path=importPath
	 */
	protected void sequence_importSpec(ISerializationContext context, importSpec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.IMPORT_SPEC__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.IMPORT_SPEC__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportSpecAccess().getPathImportPathParserRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     incDecStmt returns incDecStmt
	 *
	 * Constraint:
	 *     expr=expression
	 */
	protected void sequence_incDecStmt(ISerializationContext context, incDecStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.INC_DEC_STMT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.INC_DEC_STMT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncDecStmtAccess().getExprExpressionParserRuleCall_0_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     index returns index
	 *
	 * Constraint:
	 *     expr=expression
	 */
	protected void sequence_index(ISerializationContext context, index semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.INDEX__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.INDEX__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndexAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     interfaceType returns interfaceType
	 *
	 * Constraint:
	 *     methodSpecs+=methodSpec+
	 */
	protected void sequence_interfaceType(ISerializationContext context, interfaceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     key returns key
	 *
	 * Constraint:
	 *     (name=IDENTIFIER | expr=expression | lit=literalValue)
	 */
	protected void sequence_key(ISerializationContext context, key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     keyedElement returns keyedElement
	 *
	 * Constraint:
	 *     (key=key? element=element)
	 */
	protected void sequence_keyedElement(ISerializationContext context, keyedElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     labeledStmt returns labeledStmt
	 *
	 * Constraint:
	 *     (label=IDENTIFIER stmt=statement)
	 */
	protected void sequence_labeledStmt(ISerializationContext context, labeledStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LABELED_STMT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LABELED_STMT__LABEL));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LABELED_STMT__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LABELED_STMT__STMT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabeledStmtAccess().getLabelIDENTIFIERTerminalRuleCall_0_0(), semanticObject.getLabel());
		feeder.accept(grammarAccess.getLabeledStmtAccess().getStmtStatementParserRuleCall_2_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     literalType returns literalType
	 *
	 * Constraint:
	 *     (
	 *         type=structType | 
	 *         type=arrayType | 
	 *         type=elementType | 
	 *         type=sliceType | 
	 *         type=mapType | 
	 *         type=typeName
	 *     )
	 */
	protected void sequence_literalType(ISerializationContext context, literalType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     literalValue returns literalValue
	 *
	 * Constraint:
	 *     elementList=elementList
	 */
	protected void sequence_literalValue(ISerializationContext context, literalValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.LITERAL_VALUE__ELEMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.LITERAL_VALUE__ELEMENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralValueAccess().getElementListElementListParserRuleCall_1_0_0(), semanticObject.getElementList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     literal returns literal
	 *
	 * Constraint:
	 *     (litBasic=basicLit | litComposite=compositeLit | litFunc=functionLit)
	 */
	protected void sequence_literal(ISerializationContext context, literal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     mapType returns mapType
	 *
	 * Constraint:
	 *     (type=type elemType=elementType)
	 */
	protected void sequence_mapType(ISerializationContext context, mapType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.MAP_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.MAP_TYPE__TYPE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.MAP_TYPE__ELEM_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.MAP_TYPE__ELEM_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapTypeAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getMapTypeAccess().getElemTypeElementTypeParserRuleCall_4_0(), semanticObject.getElemType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     methodDecl returns methodDecl
	 *
	 * Constraint:
	 *     (params=receiver name=IDENTIFIER (func=function | sig=signature))
	 */
	protected void sequence_methodDecl(ISerializationContext context, methodDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     methodExpr returns methodExpr
	 *
	 * Constraint:
	 *     receiverType=receiverType
	 */
	protected void sequence_methodExpr(ISerializationContext context, methodExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.METHOD_EXPR__RECEIVER_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.METHOD_EXPR__RECEIVER_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMethodExprAccess().getReceiverTypeReceiverTypeParserRuleCall_0_0(), semanticObject.getReceiverType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     methodSpec returns methodSpec
	 *
	 * Constraint:
	 *     ((name=IDENTIFIER sig=signature) | typeName=typeName)
	 */
	protected void sequence_methodSpec(ISerializationContext context, methodSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     operandName returns operandName
	 *
	 * Constraint:
	 *     (name=IDENTIFIER | qualIdent=qualifiedIdent)
	 */
	protected void sequence_operandName(ISerializationContext context, operandName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     operand returns operand
	 *
	 * Constraint:
	 *     (content=literal | content=operandName | content=methodExpr | content=expression)
	 */
	protected void sequence_operand(ISerializationContext context, operand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     packageClause returns packageClause
	 *
	 * Constraint:
	 *     packageName=IDENTIFIER
	 */
	protected void sequence_packageClause(ISerializationContext context, packageClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PACKAGE_CLAUSE__PACKAGE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PACKAGE_CLAUSE__PACKAGE_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPackageClauseAccess().getPackageNameIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getPackageName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     parameterDecl returns parameterDecl
	 *
	 * Constraint:
	 *     (identifierList=identifierList? type=type)
	 */
	protected void sequence_parameterDecl(ISerializationContext context, parameterDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameterList returns parameterList
	 *
	 * Constraint:
	 *     (paramsDecl+=parameterDecl paramsDecl+=parameterDecl*)
	 */
	protected void sequence_parameterList(ISerializationContext context, parameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameters returns parameters
	 *
	 * Constraint:
	 *     paramList+=parameterList
	 */
	protected void sequence_parameters(ISerializationContext context, parameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     pointerType returns pointerType
	 *
	 * Constraint:
	 *     type=type
	 */
	protected void sequence_pointerType(ISerializationContext context, pointerType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.POINTER_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.POINTER_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPointerTypeAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primaryExprArguments returns primaryExprArguments
	 *
	 * Constraint:
	 *     (content=primaryExprStuff primaryExprArguments=primaryExprArguments)
	 */
	protected void sequence_primaryExprArguments(ISerializationContext context, primaryExprArguments semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR_ARGUMENTS__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR_ARGUMENTS__CONTENT));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR_ARGUMENTS__PRIMARY_EXPR_ARGUMENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR_ARGUMENTS__PRIMARY_EXPR_ARGUMENTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExprArgumentsAccess().getContentPrimaryExprStuffParserRuleCall_0_0(), semanticObject.getContent());
		feeder.accept(grammarAccess.getPrimaryExprArgumentsAccess().getPrimaryExprArgumentsPrimaryExprArgumentsParserRuleCall_1_0(), semanticObject.getPrimaryExprArguments());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primaryExprIndex returns primaryExprIndex
	 *
	 * Constraint:
	 *     (content=primaryExprStuff primaryExprIndex=primaryExprIndex)
	 */
	protected void sequence_primaryExprIndex(ISerializationContext context, primaryExprIndex semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR_INDEX__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR_INDEX__CONTENT));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR_INDEX__PRIMARY_EXPR_INDEX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR_INDEX__PRIMARY_EXPR_INDEX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExprIndexAccess().getContentPrimaryExprStuffParserRuleCall_0_0(), semanticObject.getContent());
		feeder.accept(grammarAccess.getPrimaryExprIndexAccess().getPrimaryExprIndexPrimaryExprIndexParserRuleCall_1_0(), semanticObject.getPrimaryExprIndex());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primaryExprSelector returns primaryExprSelector
	 *
	 * Constraint:
	 *     (content=primaryExprStuff primaryExprSelector=primaryExprSelector)
	 */
	protected void sequence_primaryExprSelector(ISerializationContext context, primaryExprSelector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR_SELECTOR__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR_SELECTOR__CONTENT));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR_SELECTOR__PRIMARY_EXPR_SELECTOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR_SELECTOR__PRIMARY_EXPR_SELECTOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExprSelectorAccess().getContentPrimaryExprStuffParserRuleCall_0_0(), semanticObject.getContent());
		feeder.accept(grammarAccess.getPrimaryExprSelectorAccess().getPrimaryExprSelectorPrimaryExprSelectorParserRuleCall_1_0(), semanticObject.getPrimaryExprSelector());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primaryExprSlice returns primaryExprSlice
	 *
	 * Constraint:
	 *     (content=primaryExprStuff primaryExprSlice=primaryExprSlice)
	 */
	protected void sequence_primaryExprSlice(ISerializationContext context, primaryExprSlice semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR_SLICE__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR_SLICE__CONTENT));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR_SLICE__PRIMARY_EXPR_SLICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR_SLICE__PRIMARY_EXPR_SLICE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExprSliceAccess().getContentPrimaryExprStuffParserRuleCall_0_0(), semanticObject.getContent());
		feeder.accept(grammarAccess.getPrimaryExprSliceAccess().getPrimaryExprSlicePrimaryExprSliceParserRuleCall_1_0(), semanticObject.getPrimaryExprSlice());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primaryExprStuff returns primaryExprStuff
	 *
	 * Constraint:
	 *     (content=selector | content=index | content=slice | content=typeAssertion | content=arguments)
	 */
	protected void sequence_primaryExprStuff(ISerializationContext context, primaryExprStuff semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     primaryExprTypeAssertion returns primaryExprTypeAssertion
	 *
	 * Constraint:
	 *     (content=primaryExprStuff primaryExprTypeAssertion=primaryExprTypeAssertion)
	 */
	protected void sequence_primaryExprTypeAssertion(ISerializationContext context, primaryExprTypeAssertion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR_TYPE_ASSERTION__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR_TYPE_ASSERTION__CONTENT));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.PRIMARY_EXPR_TYPE_ASSERTION__PRIMARY_EXPR_TYPE_ASSERTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.PRIMARY_EXPR_TYPE_ASSERTION__PRIMARY_EXPR_TYPE_ASSERTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryExprTypeAssertionAccess().getContentPrimaryExprStuffParserRuleCall_0_0(), semanticObject.getContent());
		feeder.accept(grammarAccess.getPrimaryExprTypeAssertionAccess().getPrimaryExprTypeAssertionPrimaryExprTypeAssertionParserRuleCall_1_0(), semanticObject.getPrimaryExprTypeAssertion());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     primaryExpr returns primaryExpr
	 *
	 * Constraint:
	 *     (
	 *         content=operand | 
	 *         content=conversion | 
	 *         content=primaryExprSelector | 
	 *         content=primaryExprIndex | 
	 *         content=primaryExprSlice | 
	 *         content=primaryExprTypeAssertion | 
	 *         content=primaryExprArguments
	 *     )
	 */
	protected void sequence_primaryExpr(ISerializationContext context, primaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     qualifiedIdent returns qualifiedIdent
	 *
	 * Constraint:
	 *     (packageName=IDENTIFIER name=IDENTIFIER)
	 */
	protected void sequence_qualifiedIdent(ISerializationContext context, qualifiedIdent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.QUALIFIED_IDENT__PACKAGE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.QUALIFIED_IDENT__PACKAGE_NAME));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.QUALIFIED_IDENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.QUALIFIED_IDENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQualifiedIdentAccess().getPackageNameIDENTIFIERTerminalRuleCall_0_0(), semanticObject.getPackageName());
		feeder.accept(grammarAccess.getQualifiedIdentAccess().getNameIDENTIFIERTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     rangeClause returns rangeClause
	 *
	 * Constraint:
	 *     ((exprList=expressionList | idList=identifierList)? expr=expression)
	 */
	protected void sequence_rangeClause(ISerializationContext context, rangeClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     receiverType returns receiverType
	 *
	 * Constraint:
	 *     (typeName=typeName | typeName=typeName | receiverType=receiverType)
	 */
	protected void sequence_receiverType(ISerializationContext context, receiverType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     receiver returns receiver
	 *
	 * Constraint:
	 *     params=parameters
	 */
	protected void sequence_receiver(ISerializationContext context, receiver semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.RECEIVER__PARAMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.RECEIVER__PARAMS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReceiverAccess().getParamsParametersParserRuleCall_0(), semanticObject.getParams());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     recvStmt returns recvStmt
	 *
	 * Constraint:
	 *     ((exprList=expressionList | idList=identifierList)? expr=expression)
	 */
	protected void sequence_recvStmt(ISerializationContext context, recvStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     result returns result
	 *
	 * Constraint:
	 *     (params=parameters | type=type)
	 */
	protected void sequence_result(ISerializationContext context, result semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     returnStmt returns returnStmt
	 *
	 * Constraint:
	 *     exprList=expressionList
	 */
	protected void sequence_returnStmt(ISerializationContext context, returnStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.RETURN_STMT__EXPR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.RETURN_STMT__EXPR_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnStmtAccess().getExprListExpressionListParserRuleCall_1_0(), semanticObject.getExprList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     selectStmt returns selectStmt
	 *
	 * Constraint:
	 *     commClauses+=commClause+
	 */
	protected void sequence_selectStmt(ISerializationContext context, selectStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     selector returns selector
	 *
	 * Constraint:
	 *     name=IDENTIFIER
	 */
	protected void sequence_selector(ISerializationContext context, selector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.SELECTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.SELECTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectorAccess().getNameIDENTIFIERTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     sendStmt returns sendStmt
	 *
	 * Constraint:
	 *     (expr1=expression expr2=expression)
	 */
	protected void sequence_sendStmt(ISerializationContext context, sendStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.SEND_STMT__EXPR1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.SEND_STMT__EXPR1));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.SEND_STMT__EXPR2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.SEND_STMT__EXPR2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSendStmtAccess().getExpr1ExpressionParserRuleCall_0_0(), semanticObject.getExpr1());
		feeder.accept(grammarAccess.getSendStmtAccess().getExpr2ExpressionParserRuleCall_2_0(), semanticObject.getExpr2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     shortVarDecl returns shortVarDecl
	 *
	 * Constraint:
	 *     (idList=identifierList exprList=expressionList)
	 */
	protected void sequence_shortVarDecl(ISerializationContext context, shortVarDecl semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.SHORT_VAR_DECL__ID_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.SHORT_VAR_DECL__ID_LIST));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.SHORT_VAR_DECL__EXPR_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.SHORT_VAR_DECL__EXPR_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShortVarDeclAccess().getIdListIdentifierListParserRuleCall_0_0(), semanticObject.getIdList());
		feeder.accept(grammarAccess.getShortVarDeclAccess().getExprListExpressionListParserRuleCall_2_0(), semanticObject.getExprList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     signature returns signature
	 *
	 * Constraint:
	 *     (params=parameters result=result?)
	 */
	protected void sequence_signature(ISerializationContext context, signature semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     simpleStmt returns simpleStmt
	 *
	 * Constraint:
	 *     (
	 *         content=sendStmt | 
	 *         content=expressionStmt | 
	 *         content=incDecStmt | 
	 *         content=assignment | 
	 *         content=shortVarDecl | 
	 *         content=emptyStmt
	 *     )
	 */
	protected void sequence_simpleStmt(ISerializationContext context, simpleStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     sliceType returns sliceType
	 *
	 * Constraint:
	 *     elemType=elementType
	 */
	protected void sequence_sliceType(ISerializationContext context, sliceType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.SLICE_TYPE__ELEM_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.SLICE_TYPE__ELEM_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSliceTypeAccess().getElemTypeElementTypeParserRuleCall_2_0(), semanticObject.getElemType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     slice returns slice
	 *
	 * Constraint:
	 *     ((expr1=expression? expr2=expression?) | (expr1=expression? expr2=expression expr3=expression))
	 */
	protected void sequence_slice(ISerializationContext context, slice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     sourceFile returns sourceFile
	 *
	 * Constraint:
	 *     (package=packageClause imports+=importDecl* topLevelDecls+=topLevelDecl*)
	 */
	protected void sequence_sourceFile(ISerializationContext context, sourceFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statementList returns statementList
	 *
	 * Constraint:
	 *     statements+=statement+
	 */
	protected void sequence_statementList(ISerializationContext context, statementList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement returns statement
	 *
	 * Constraint:
	 *     (
	 *         content=declaration | 
	 *         content=labeledStmt | 
	 *         content=simpleStmt | 
	 *         content=goStmt | 
	 *         content=returnStmt | 
	 *         content=breakStmt | 
	 *         content=continueStmt | 
	 *         content=gotoStmt | 
	 *         content=fallthroughStmt | 
	 *         content=block | 
	 *         content=ifStmt | 
	 *         content=switchStmt | 
	 *         content=selectStmt | 
	 *         content=forStmt | 
	 *         content=deferStmt
	 *     )
	 */
	protected void sequence_statement(ISerializationContext context, statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     structType returns structType
	 *
	 * Constraint:
	 *     fieldsDecl+=fieldDecl+
	 */
	protected void sequence_structType(ISerializationContext context, structType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     switchStmt returns switchStmt
	 *
	 * Constraint:
	 *     (statement=exprSwitchStmt | statement=typeSwitchStmt)
	 */
	protected void sequence_switchStmt(ISerializationContext context, switchStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     topLevelDecl returns topLevelDecl
	 *
	 * Constraint:
	 *     (decl=declaration | decl=functionDecl | decl=methodDecl)
	 */
	protected void sequence_topLevelDecl(ISerializationContext context, topLevelDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeAssertion returns typeAssertion
	 *
	 * Constraint:
	 *     type=type
	 */
	protected void sequence_typeAssertion(ISerializationContext context, typeAssertion semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE_ASSERTION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE_ASSERTION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAssertionAccess().getTypeTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     typeCaseClause returns typeCaseClause
	 *
	 * Constraint:
	 *     (typeSwitchCase=typeSwitchCase statementList=statementList)
	 */
	protected void sequence_typeCaseClause(ISerializationContext context, typeCaseClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE_CASE_CLAUSE__TYPE_SWITCH_CASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE_CASE_CLAUSE__TYPE_SWITCH_CASE));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE_CASE_CLAUSE__STATEMENT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE_CASE_CLAUSE__STATEMENT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeCaseClauseAccess().getTypeSwitchCaseTypeSwitchCaseParserRuleCall_0_0(), semanticObject.getTypeSwitchCase());
		feeder.accept(grammarAccess.getTypeCaseClauseAccess().getStatementListStatementListParserRuleCall_2_0(), semanticObject.getStatementList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     typeDecl returns typeDecl
	 *
	 * Constraint:
	 *     (spec+=typeSpec | spec+=typeSpec+)
	 */
	protected void sequence_typeDecl(ISerializationContext context, typeDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeList returns typeList
	 *
	 * Constraint:
	 *     (types+=type types+=type*)
	 */
	protected void sequence_typeList(ISerializationContext context, typeList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeLit returns typeLit
	 *
	 * Constraint:
	 *     (
	 *         lit=arrayType | 
	 *         lit=structType | 
	 *         lit=pointerType | 
	 *         lit=functionType | 
	 *         lit=interfaceType | 
	 *         lit=sliceType | 
	 *         lit=mapType | 
	 *         lit=channelType
	 *     )
	 */
	protected void sequence_typeLit(ISerializationContext context, typeLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeName returns typeName
	 *
	 * Constraint:
	 *     (name=IDENTIFIER | qualIdent=qualifiedIdent)
	 */
	protected void sequence_typeName(ISerializationContext context, typeName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeSpec returns typeSpec
	 *
	 * Constraint:
	 *     (name=IDENTIFIER type=type)
	 */
	protected void sequence_typeSpec(ISerializationContext context, typeSpec semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE_SPEC__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE_SPEC__NAME));
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE_SPEC__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE_SPEC__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeSpecAccess().getNameIDENTIFIERTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTypeSpecAccess().getTypeTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     typeSwitchCase returns typeSwitchCase
	 *
	 * Constraint:
	 *     typeList=typeList
	 */
	protected void sequence_typeSwitchCase(ISerializationContext context, typeSwitchCase semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GoPackage.Literals.TYPE_SWITCH_CASE__TYPE_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GoPackage.Literals.TYPE_SWITCH_CASE__TYPE_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeSwitchCaseAccess().getTypeListTypeListParserRuleCall_0_1_0(), semanticObject.getTypeList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     typeSwitchGuard returns typeSwitchGuard
	 *
	 * Constraint:
	 *     (name=IDENTIFIER? primaryExpression=primaryExpr)
	 */
	protected void sequence_typeSwitchGuard(ISerializationContext context, typeSwitchGuard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeSwitchStmt returns typeSwitchStmt
	 *
	 * Constraint:
	 *     (simpleStatement=simpleStmt? typeSwitchGuard=typeSwitchGuard typeCaseClauses+=typeCaseClause*)
	 */
	protected void sequence_typeSwitchStmt(ISerializationContext context, typeSwitchStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns type
	 *
	 * Constraint:
	 *     (content=typeName | content=typeLit | content=type)
	 */
	protected void sequence_type(ISerializationContext context, type semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unaryExpr returns unaryExpr
	 *
	 * Constraint:
	 *     (primaryExpr=primaryExpr | unaryExpr=unaryExpr)
	 */
	protected void sequence_unaryExpr(ISerializationContext context, unaryExpr semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     varDecl returns varDecl
	 *
	 * Constraint:
	 *     (specs+=varSpec | specs+=varSpec+)
	 */
	protected void sequence_varDecl(ISerializationContext context, varDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     varSpec returns varSpec
	 *
	 * Constraint:
	 *     (idList=identifierList ((type=type exprList+=expressionList?) | exprList+=expressionList))
	 */
	protected void sequence_varSpec(ISerializationContext context, varSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
